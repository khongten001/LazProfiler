LazarusResources.Add('rt','PAS',[
  '{'#13#10'    Copyright (c) 2017 Pascal Riekenberg'#13#10#13#10'    LazProfil'
  +'er: Runtime unit'#13#10#13#10'    See the file COPYING.modifiedLGPL.txt, in'
  +'cluded in this distribution,'#13#10'    for details about the license.'#13
  +#10#13#10'    This program is distributed in the hope that it will be useful'
  +','#13#10'    but WITHOUT ANY WARRANTY; without even the implied warranty of'
  +#13#10'    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.'#13#10#13#10
  +' **********************************************************************}'#13
  +#10#13#10'unit LazProfilerRunTime;'#13#10#13#10'{$mode objfpc}{$H+}'#13#10#13
  +#10'interface'#13#10#13#10'uses'#13#10'  Classes, SysUtils, LazProfilerCore;'
  +#13#10#13#10'var'#13#10'  LazProfiler: TLazProfiler;'#13#10#13#10'implementa'
  +'tion'#13#10#13#10'initialization'#13#10#13#10'  LazProfiler := TLazProfiler'
  +'.Create(ParamStr(0));'#13#10#13#10'finalization'#13#10#13#10'  FreeAndNil(L'
  +'azProfiler);'#13#10#13#10'end.'#13#10#13#10
]);
LazarusResources.Add('core','PAS',[
  '{'#13#10'    Copyright (c) 2017 Pascal Riekenberg'#13#10#13#10'    LazProfil'
  +'er: Core unit'#13#10#13#10'    See the file COPYING.modifiedLGPL.txt, inclu'
  +'ded in this distribution,'#13#10'    for details about the license.'#13#10
  +#13#10'    This program is distributed in the hope that it will be useful,'
  +#13#10'    but WITHOUT ANY WARRANTY; without even the implied warranty of'#13
  +#10'    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.'#13#10#13#10' *'
  +'*********************************************************************}'#13
  +#10#13#10'unit LazProfilerCore;'#13#10#13#10'{$mode objfpc}{$H+}'#13#10#13#10
  +'interface'#13#10#13#10'uses'#13#10'  Classes,'#13#10'  EpikTimer,'#13#10'  '
  +'Generics.Collections,'#13#10'  Generics.Defaults,'#13#10'  SysUtils;'#13#10
  +#13#10'type'#13#10#13#10'  TIntegerList = specialize TList<Integer>;'#13#10
  +#13#10#13#10'  { TLPBaseType }'#13#10#13#10'  TLPBaseType = class'#13#10'  p'
  +'rivate'#13#10'  protected'#13#10'    fExpanded: Boolean;'#13#10'  public'#13
  +#10'    property Expanded: Boolean read fExpanded write fExpanded;'#13#10'  '
  +'end;'#13#10#13#10#13#10'  { TLPPasUnit }'#13#10#13#10'  TLPPasUnit = class('
  +'TLPBaseType)'#13#10'  private'#13#10'    procedure SetFileName(pFileName: s'
  +'tring);'#13#10'    procedure SetUnitName(pUnitName: String);'#13#10'  prote'
  +'cted'#13#10'    fUnitName,'#13#10'    fFileName,'#13#10'    fUnitNameUp,'#13
  +#10'    fFileNameUp: String;'#13#10'  public'#13#10'    constructor Create(p'
  +'UnitName, pFileName: String);'#13#10'    property UnitName: String read fUn'
  +'itName write SetUnitName;'#13#10'    property FileName: string read fFileNa'
  +'me write SetFileName;'#13#10'    property UnitNameUp: String read fUnitName'
  +'Up;'#13#10'    property FileNameUp: String read fFileNameUp;'#13#10'  end;'
  +#13#10#13#10#13#10'  { TLPPasUnitList }'#13#10#13#10'  TLPPasUnitList = clas'
  +'s(specialize TObjectList<TLPPasUnit>)'#13#10'  private'#13#10'  protected'
  +#13#10'  public'#13#10'    function IndexOf(pUnitName, pFileName: String): S'
  +'izeInt; overload;'#13#10'    procedure SaveToStringList(pList: TStringList)'
  +';'#13#10'    procedure LoadFromStringList(pList: TStringList; pVersion: Int'
  +'eger);'#13#10'  end;'#13#10#13#10#13#10'  { TLPPasClass }'#13#10#13#10'  TL'
  +'PPasClass = class(TLPPasUnit)'#13#10'  private'#13#10'    procedure SetName'
  +'OfClass(pNameOfClass: String);'#13#10'  protected'#13#10'    fNameOfClass,'
  +#13#10'    fNameOfClassUp: String;'#13#10'    fPasUnit: TLPPasUnit;'#13#10' '
  +' public'#13#10'    constructor Create(pNameOfClass, pUnitName, pFileName: S'
  +'tring);'#13#10'    property PasUnit: TLPPasUnit read fPasUnit write fPasUni'
  +'t;'#13#10'    property NameOfClass: String read fNameOfClass write SetNameO'
  +'fClass;'#13#10'    property NameOfClassUp: String read fNameOfClassUp;'#13
  +#10'  end;'#13#10#13#10#13#10'  { TLPPasClassList }'#13#10#13#10'  TLPPasCla'
  +'ssList = class(specialize TObjectList<TLPPasClass>)'#13#10'  private'#13#10
  +'  protected'#13#10'  public'#13#10'    function IndexOf(pNameOfClass, pUnit'
  +'Name, pFileName: String): SizeInt; overload;'#13#10'    procedure SaveToStr'
  +'ingList(pList: TStringList);'#13#10'    procedure LoadFromStringList(pList:'
  +' TStringList; pVersion: Integer);'#13#10'  end;'#13#10#13#10#13#10'  { TLPP'
  +'roc }'#13#10#13#10'  TLPPasProcList = class;'#13#10#13#10'  { TLPPasProc }'
  +#13#10#13#10'  TLPPasProc = class(TLPPasClass)'#13#10'  private'#13#10'    f'
  +'Name,'#13#10'    fNameUp: String;'#13#10'    fRow: Integer;'#13#10'    fNet'
  +','#13#10'    fGross: QWord;'#13#10'    fCount: Integer;'#13#10'    fKind: I'
  +'nteger;'#13#10'    fCalls,'#13#10'    fCalledBy: TLPPasProcList;'#13#10'   '
  +' fCallsCount,'#13#10'    fCalledByCount: TIntegerList;'#13#10'    fInstrume'
  +'nt: Boolean;'#13#10'    fPasClass: TLPPasClass;'#13#10'    procedure SetFil'
  +'eName(pFileName: String);'#13#10'    procedure SetName(pName: String);'#13
  +#10'  public'#13#10'    constructor Create(pName: String; pKind: Integer; pN'
  +'ameOfClass, pUnitName, pFileName: String; pRow: Integer);'#13#10'    destru'
  +'ctor Destroy; override;'#13#10'    procedure Init;'#13#10'    procedure Cal'
  +'ls(pProc: TLPPasProc);'#13#10'    procedure CalledBy(pProc: TLPPasProc);'#13
  +#10'    property Name: String read fName write SetName;'#13#10'    property '
  +'Row: Integer read fRow write fRow;'#13#10'    property Count: Integer read '
  +'fCount write fCount;'#13#10'    property Kind: Integer read fKind write fKi'
  +'nd;'#13#10'    property Net: QWord read fNet write fNet;'#13#10'    propert'
  +'y Gross: QWord read fGross write fGross;'#13#10'    property Instrument: Bo'
  +'olean read fInstrument write fInstrument;'#13#10'    property NameUp: strin'
  +'g read fNameUp;'#13#10'    property PasClass: TLPPasClass read fPasClass wr'
  +'ite fPasClass;'#13#10'  end;'#13#10'  PLPPasProc = ^TLPPasProc;'#13#10#13#10
  +#13#10'  { TLPPasProcList }'#13#10#13#10'  TLPPasProcList = class(specialize'
  +' TObjectList<TLPPasProc>)'#13#10'  private'#13#10'    fCallCount: Integer;'
  ,#13#10'  public'#13#10'    constructor Create(pOwnsObjects: Boolean = True);'
  +' overload;'#13#10'    procedure Init;'#13#10'    procedure Convert(pTicks: '
  +'ticktype);'#13#10'    function IndexOf(pName, pNameOfClass, pUnitName, pFil'
  +'eName: String): SizeInt;'#13#10'      overload;'#13#10'    procedure SaveTo'
  +'StringList(pList: TStringList);'#13#10'    procedure LoadFromStringList(pLi'
  +'st: TStringList; pVersion: Integer);'#13#10'    property CallCount: Integer'
  +' read fCallCount write fCallCount;'#13#10'  end;'#13#10#13#10#13#10'  { TLP'
  +'StackFrame }'#13#10#13#10'  TLPStackFrame = class;'#13#10'  TLPStackFrameLi'
  +'st = specialize TObjectList<TLPStackFrame>;'#13#10#13#10'  TLPStackFrame = '
  +'class'#13#10'  private'#13#10'    fPasProc: TLPPasProc;'#13#10'    fChildLi'
  +'st: TLPStackFrameList;'#13#10'    fParent: TLPStackFrame;'#13#10'    fRunni'
  +'ng: Boolean;'#13#10'    fTicksInit,'#13#10'    fTicksStart,'#13#10'    fTic'
  +'ksEnd,'#13#10'    fTicksExit,'#13#10'    fNet,'#13#10'    fGross,'#13#10'  '
  +'  fOverhead,'#13#10'    fOff: TickType;'#13#10'  protected'#13#10'  public'
  +#13#10'    procedure Calc;'#13#10'    procedure CleanupChilds;'#13#10'    co'
  +'nstructor Create(pProc: TLPPasProc; pParent: TLPStackFrame);'#13#10'    des'
  +'tructor Destroy; override;'#13#10'  end;'#13#10#13#10#13#10'  { TCustomLazP'
  +'rofiler }'#13#10#13#10'  TCustomLazProfiler = class'#13#10'  protected'#13
  +#10'    fUnitList: TLPPasUnitList;'#13#10'    fClassList: TLPPasClassList;'
  +#13#10'    fProcList: TLPPasProcList;'#13#10'    fAutoStart: Boolean;'#13#10
  +'    fNeedsRebuild: Boolean;'#13#10'    fSortColumn: Integer;'#13#10'    fSo'
  +'rtDirection: Integer;'#13#10'    procedure SaveToFile(pFileName: String);'
  +#13#10'    function LoadFromFile(pFileName: String): Boolean;'#13#10'  publi'
  +'c'#13#10'    constructor Create;'#13#10'    destructor Destroy; override;'
  +#13#10'    property ProcList: TLPPasProcList read fProcList;'#13#10'    prop'
  +'erty SortColumn: Integer read fSortColumn write fSortColumn;'#13#10'    pro'
  +'perty SortDirection: Integer read fSortDirection write fSortDirection;'#13
  +#10'  end;'#13#10#13#10#13#10'  { TLazProfiler }'#13#10#13#10'  TLazProfiler'
  +' = class(TCustomLazProfiler)'#13#10'  private'#13#10'    fMasterProc: TLPPa'
  +'sProc;'#13#10'    fName: String;'#13#10'    fTimer: TEpikTimer;'#13#10'    '
  +'fTicks: TickType;'#13#10'    fThreads: TList;'#13#10'    fCurStackFrame: ar'
  +'ray of TLPStackFrame;'#13#10'    fRunning: Boolean;'#13#10'    fPauseCount:'
  +' Integer;'#13#10'    fPauseStartTicks,'#13#10'    fOffTicks: TickType;'#13
  +#10'    fLoaded: Boolean;'#13#10'    Ticks: function: Ticktype of object;'#13
  +#10'    fLock: TRTLCriticalSection;'#13#10'    function GetOffTicks: TickTyp'
  +'e;'#13#10'    function HWTicks: Ticktype;'#13#10'    function SysTicks: Tic'
  +'ktype;'#13#10'    function ThreadIndex(pThread: TThreadID): Integer;'#13#10
  +'    procedure Lock;'#13#10'    procedure UnLock;'#13#10'  protected'#13#10
  +'  public'#13#10'    procedure EnterProfiling(pProcID: Integer);'#13#10'    '
  +'procedure ExitProfiling(pProcID: Integer);'#13#10'    procedure StartProfil'
  +'ing;'#13#10'    procedure PauseProfiling;'#13#10'    procedure ContinueProf'
  +'iling;'#13#10'    procedure StopProfiling;'#13#10'    constructor Create(pP'
  +'rogramm: String);'#13#10'    destructor Destroy; override;'#13#10'    prope'
  +'rty OffTicks: TickType read GetOffTicks;'#13#10'    property PauseStart: Ti'
  +'ckType read fPauseStartTicks;'#13#10'  end;'#13#10#13#10'const'#13#10'  cBa'
  +'ckupExtension  = ''.lazprofiler_backup'';'#13#10#13#10'  cCoreFileName = '''
  +'LazProfilerCore.pas'';'#13#10'  cRunTimeFileName = ''LazProfilerRunTime.pas'
  +''';'#13#10'  cTimerFileName = ''EpikTimer.pas'';'#13#10#13#10'  cSettingExt'
  +'ension = ''.lazprofiler_setting'';'#13#10'  cSettingVersion = 2;'#13#10#13
  +#10'implementation'#13#10#13#10'uses'#13#10'  LazLogger, LazFileUtils, strut'
  +'ils, Dialogs;'#13#10#13#10'{ TLPPasUnitList }'#13#10#13#10'function TLPPasU'
  +'nitList.IndexOf(pUnitName, pFileName: String): SizeInt;'#13#10'var'#13#10' '
  +' i: Integer;'#13#10'  lPasUnit: TLPPasUnit;'#13#10'begin'#13#10'  pUnitName'
  +' := UpperCase(pUnitName);'#13#10'  pFileName := UpperCase(pFileName);'#13#10
  +'  for i := 0 to Count - 1 do begin'#13#10'    lPasUnit := Items[i];'#13#10
  +'    if (lPasUnit.UnitNameUp = pUnitName)'#13#10'    and (lPasUnit.FileNameU'
  +'p = pFileName) then'#13#10'      Exit(i);'#13#10'  end;'#13#10'  Result := '
  +'-1;'#13#10'end;'#13#10#13#10'procedure TLPPasUnitList.SaveToStringList(pLis'
  +'t: TStringList);'#13#10'var'#13#10'  lLine: TStringList;'#13#10'  i: Intege'
  +'r;'#13#10'begin'#13#10'  lLine := TStringList.Create;'#13#10'  try'#13#10' '
  +'   lLine.Delimiter := '';'';'#13#10'    lLine.StrictDelimiter := True;'#13
  +#10'    for i := 0 to Count - 1 do begin'#13#10'      lLine.Clear;'#13#10'  '
  +'    lLine.Add(Items[i].UnitName);'#13#10'      lLine.Add(Items[i].FileName)'
  +';'#13#10'      lLine.Add(BoolToStr(Items[i].Expanded, True));'#13#10'      '
  ,'pList.Add(lLine.DelimitedText);'#13#10'    end;'#13#10'  finally'#13#10'   '
  +' lLine.Free;'#13#10'  end;'#13#10'end;'#13#10#13#10'procedure TLPPasUnitLis'
  +'t.LoadFromStringList(pList: TStringList; pVersion: Integer);'#13#10'var'#13
  +#10'  lLine: TStringList;'#13#10'  i: Integer;'#13#10'begin'#13#10'  lLine :'
  +'= TStringList.Create;'#13#10'  try'#13#10'    lLine.Delimiter := '';'';'#13
  +#10'    lLine.StrictDelimiter := True;'#13#10'    if pList.Count = 0 then'#13
  +#10'      exit;'#13#10'    for i := 0 to pList.Count - 1 do begin'#13#10'   '
  +'   lLine.DelimitedText := pList[i];'#13#10'      if lLine.Count >= 3 then b'
  +'egin'#13#10'        Add(TLPPasUnit.Create(lLine[0], lLine[1]));'#13#10'    '
  +'    Last.Expanded := StrToBool(lLine[2]);'#13#10'      end;'#13#10'    end;'
  +#13#10'  finally'#13#10'    lLine.Free;'#13#10'  end;'#13#10'end;'#13#10#13
  +#10#13#10'{ TLPPasClassList }'#13#10#13#10'function TLPPasClassList.IndexOf('
  +'pNameOfClass, pUnitName, pFileName: String): SizeInt;'#13#10'var'#13#10'  i'
  +': Integer;'#13#10'  lPasClass: TLPPasClass;'#13#10'begin'#13#10'  pNameOfCl'
  +'ass := UpperCase(pNameOfClass);'#13#10'  pUnitName := UpperCase(pUnitName);'
  +#13#10'  pFileName := UpperCase(pFileName);'#13#10'  for i := 0 to Count - 1'
  +' do begin'#13#10'    lPasClass := Items[i];'#13#10'    if (lPasClass.fNameO'
  +'fClassUp = pNameOfClass)'#13#10'    and (lPasClass.fUnitNameUp = pUnitName)'
  +#13#10'    and (lPasClass.fFileNameUp = pFileName) then'#13#10'      Exit(i)'
  +';'#13#10'  end;'#13#10'  Result := -1;'#13#10'end;'#13#10#13#10'procedure T'
  +'LPPasClassList.SaveToStringList(pList: TStringList);'#13#10'var'#13#10'  lL'
  +'ine: TStringList;'#13#10'  i: Integer;'#13#10'begin'#13#10'  lLine := TStri'
  +'ngList.Create;'#13#10'  try'#13#10'    lLine.Delimiter := '';'';'#13#10'   '
  +' lLine.StrictDelimiter := True;'#13#10'    for i := 0 to Count - 1 do begin'
  +#13#10'      lLine.Clear;'#13#10'      lLine.Add(Items[i].NameOfClass);'#13
  +#10'      lLine.Add(Items[i].UnitName);'#13#10'      lLine.Add(Items[i].File'
  +'Name);'#13#10'      lLine.Add(BoolToStr(Items[i].Expanded, True));'#13#10' '
  +'     pList.Add(lLine.DelimitedText);'#13#10'    end;'#13#10'  finally'#13#10
  +'    lLine.Free;'#13#10'  end;'#13#10'end;'#13#10#13#10'procedure TLPPasClas'
  +'sList.LoadFromStringList(pList: TStringList; pVersion: Integer);'#13#10'var'
  +#13#10'  lLine: TStringList;'#13#10'  i: Integer;'#13#10'begin'#13#10'  lLin'
  +'e := TStringList.Create;'#13#10'  try'#13#10'    lLine.Delimiter := '';'';'
  +#13#10'    lLine.StrictDelimiter := True;'#13#10'    if pList.Count = 0 then'
  +#13#10'      exit;'#13#10'    for i := 0 to pList.Count - 1 do begin'#13#10
  +'      lLine.DelimitedText := pList[i];'#13#10'      if lLine.Count >= 4 the'
  +'n begin'#13#10'        Add(TLPPasClass.Create(lLine[0], lLine[1], lLine[2])'
  +');'#13#10'        Last.Expanded := StrToBool(lLine[3]);'#13#10'      end;'
  +#13#10'    end;'#13#10'  finally'#13#10'    lLine.Free;'#13#10'  end;'#13#10
  +'end;'#13#10#13#10#13#10'{ TLPPasClass }'#13#10#13#10'procedure TLPPasClass.'
  +'SetNameOfClass(pNameOfClass: String);'#13#10'begin'#13#10'  if fNameOfClass'
  +' = pNameOfClass then Exit;'#13#10'  fNameOfClass := pNameOfClass;'#13#10'  '
  +'fNameOfClassUp := UpperCase(pNameOfClass);'#13#10'end;'#13#10#13#10'constru'
  +'ctor TLPPasClass.Create(pNameOfClass, pUnitName, pFileName: String);'#13#10
  +'begin'#13#10'  inherited Create(pUnitName, pFileName);'#13#10'  fNameOfClas'
  +'s := pNameOfClass;'#13#10'  fNameOfClassUp := UpperCase(pNameOfClass);'#13
  +#10'end;'#13#10#13#10#13#10'{ TLPPasUnit }'#13#10#13#10'procedure TLPPasUnit'
  +'.SetFileName(pFileName: string);'#13#10'begin'#13#10'  if fFileName = pFile'
  +'Name then Exit;'#13#10'  fFileName := pFileName;'#13#10'  fFileNameUp := Up'
  +'perCase(pFileName);'#13#10'end;'#13#10#13#10'procedure TLPPasUnit.SetUnitNa'
  +'me(pUnitName: String);'#13#10'begin'#13#10'  if fUnitName = pUnitName then '
  +'Exit;'#13#10'  fUnitName := pUnitName;'#13#10'  fUnitNameUp := UpperCase(pU'
  +'nitName);'#13#10'end;'#13#10#13#10'constructor TLPPasUnit.Create(pUnitName,'
  +' pFileName: String);'#13#10'begin'#13#10'  fUnitName := pUnitName;'#13#10' '
  +' fUnitNameUp := UpperCase(pUnitName);'#13#10'  fFileName := pFileName;'#13
  +#10'  fFileNameUp := UpperCase(pFileName);'#13#10'end;'#13#10#13#10#13#10'{ '
  +'TCustomLazProfiler }'#13#10#13#10'procedure TCustomLazProfiler.SaveToFile(p'
  +'FileName: String);'#13#10'var'#13#10'  lFile,'#13#10'  lLine: TStringList;'
  +#13#10'  i: Integer;'#13#10'begin'#13#10'  lFile := TStringList.Create;'#13
  +#10'  lLine := TStringList.Create;'#13#10'  try'#13#10'    // header'#13#10
  +'    lLine.Delimiter := '';'';'#13#10'    lLine.StrictDelimiter := True;'#13
  +#10'    lLine.Clear;'#13#10'    lLine.Add(IntToStr(cSettingVersion));'#13#10
  +'    lLine.Add(ifthen(fAutoStart, ''AutoStart'', ''''));'#13#10'    lLine.Ad'
  +'d(ifthen(fNeedsRebuild, ''NeedsRebuild'', ''''));'#13#10'    lLine.Add(IntT'
  +'oStr(fSortColumn));'#13#10'    lLine.Add(IntToStr(fSortDirection));'#13#10
  ,'    lLine.Add(IntToStr(fUnitList.Count));'#13#10'    lLine.Add(IntToStr(fCl'
  +'assList.Count));'#13#10'    lLine.Add(IntToStr(fProcList.Count));'#13#10'  '
  +'  lFile.Add(lLine.DelimitedText);'#13#10'    // units'#13#10'    fUnitList.'
  +'SaveToStringList(lFile);'#13#10'    // classes'#13#10'    fClassList.SaveTo'
  +'StringList(lFile);'#13#10'    // procs'#13#10'    fProcList.SaveToStringLis'
  +'t(lFile);'#13#10'    lFile.SaveToFile(pFileName);'#13#10'  finally'#13#10' '
  +'   lLine.Free;'#13#10'    lFile.Free;'#13#10'  end;'#13#10'end;'#13#10#13#10
  +'function TCustomLazProfiler.LoadFromFile(pFileName: String): Boolean;'#13#10
  +'var'#13#10'  lFile, lLine, lTemp: TStringList;'#13#10'  lVersion, lUnitCoun'
  +'t, lClassCount, lProcCount: LongInt;'#13#10'  lPasClass: TLPPasClass;'#13#10
  +'  lPasUnit: TLPPasUnit;'#13#10'  lPasProc: TLPPasProc;'#13#10'  i, j, p: In'
  +'teger;'#13#10'begin'#13#10'  DebugLn(''*** LazProfiler: LoadFromFile: ''+pF'
  +'ileName);'#13#10'  if not FileExists(pFileName) then'#13#10'    Exit(False)'
  +';'#13#10'  Result := True;'#13#10'  lFile := TStringList.Create;'#13#10'  l'
  +'Line := TStringList.Create;'#13#10'  lTemp := TStringList.Create;'#13#10'  '
  +'fProcList.Clear;'#13#10'  try'#13#10'    lFile.LoadFromFile(pFileName);'#13
  +#10'    if lFile.Count >= 1 then begin'#13#10'      lLine.Delimiter := '';'''
  +';'#13#10'      lLine.StrictDelimiter := True;'#13#10'      lLine.DelimitedT'
  +'ext := lFile[0];'#13#10'      if lLine.Count >= 3 then begin'#13#10'       '
  +' lVersion := StrToInt(lLine[0]);'#13#10'        If UpperCase(lLine[1]) = '''
  +'AUTOSTART'' then'#13#10'          fAutoStart := True;'#13#10'        If Upp'
  +'erCase(lLine[2]) = ''NEEDSREBUILD'' then'#13#10'          fNeedsRebuild := '
  +'True;'#13#10'        if lVersion > 1 then begin'#13#10'          fSortColum'
  +'n := StrToInt(lLine[3]);'#13#10'          fSortDirection := StrToInt(lLine['
  +'4]);'#13#10'          lUnitCount := StrToInt(lLine[5]);'#13#10'          lC'
  +'lassCount := StrToInt(lLine[6]);'#13#10'          lProcCount := StrToInt(lL'
  +'ine[7]);'#13#10'        end;'#13#10'      end else'#13#10'        Exit;'#13
  +#10'      lFile.Delete(0);'#13#10'      if lVersion = 1 then begin'#13#10'  '
  +'      if lFile.Count > 0 then'#13#10'          fProcList.LoadFromStringList'
  +'(lFile, lVersion);'#13#10'      end else begin'#13#10'        p := 0;'#13#10
  +'        if lUnitCount > 0 then begin;'#13#10'          lTemp.Clear;'#13#10
  +'          for i := 0 to lUnitCount - 1 do begin'#13#10'            lTemp.Ad'
  +'d(lFile[p]);'#13#10'            inc(p);'#13#10'          end;'#13#10'      '
  +'    fUnitList.LoadFromStringList(lTemp, lVersion);'#13#10'        end;'#13
  +#10'        if lClassCount > 0 then begin;'#13#10'          lTemp.Clear;'#13
  +#10'          for i := 0 to lClassCount - 1 do begin'#13#10'            lTem'
  +'p.Add(lFile[p]);'#13#10'            inc(p);'#13#10'          end;'#13#10'  '
  +'        fClassList.LoadFromStringList(lTemp, lVersion);'#13#10'        end;'
  +#13#10'        if lProcCount > 0 then begin;'#13#10'          lTemp.Clear;'
  +#13#10'          for i := 0 to lProcCount - 1 do begin'#13#10'            lT'
  +'emp.Add(lFile[p]);'#13#10'            inc(p);'#13#10'          end;'#13#10
  +'          fProcList.LoadFromStringList(lTemp, lVersion);'#13#10'        end'
  +';'#13#10'      end;'#13#10'      for i := 0 to fProcList.Count - 1 do begin'
  +#13#10'        lPasProc := fProcList[i];'#13#10'        // search unit'#13#10
  +'        j := fUnitList.IndexOf(lPasProc.UnitName, lPasProc.FileName);'#13#10
  +'        if j >= 0 then begin'#13#10'          lPasUnit := fUnitList[j]'#13
  +#10'        end else begin'#13#10'          lPasUnit := TLPPasUnit.Create(lP'
  +'asProc.UnitName, lPasProc.FileName);'#13#10'          fUnitList.Add(lPasUni'
  +'t);'#13#10'        end;'#13#10'        // search class'#13#10'        j := '
  +'fClassList.IndexOf(lPasProc.NameOfClass, lPasProc.UnitName, lPasProc.FileNa'
  +'me);'#13#10'        if j >= 0 then begin'#13#10'          lPasClass := fCla'
  +'ssList[j]'#13#10'        end else begin'#13#10'          lPasClass := TLPPa'
  +'sClass.Create(lPasProc.NameOfClass, lPasProc.UnitName, lPasProc.FileName);'
  +#13#10'          fClassList.Add(lPasClass);'#13#10'        end;'#13#10'     '
  +'   // connect'#13#10'        lPasClass.PasUnit := lPasUnit;'#13#10'        '
  +'lPasProc.PasUnit := lPasUnit;'#13#10'        lPasProc.PasClass := lPasClass'
  +';'#13#10'      end;'#13#10'    end;'#13#10'    //DebugLn(''   Count=''+IntT'
  +'oStr(fProcList.Count));'#13#10'  finally'#13#10'    lTemp.Free;'#13#10'    '
  +'lLine.Free;'#13#10'    lFile.Free;'#13#10'  end;'#13#10'end;'#13#10#13#10'c'
  +'onstructor TCustomLazProfiler.Create;'#13#10'begin'#13#10'  inherited Creat'
  +'e;'#13#10'  fClassList := TLPPasClassList.Create(True);'#13#10'  fUnitList '
  +':= TLPPasUnitList.Create(True);'#13#10'  fProcList := TLPPasProcList.Create'
  +'(True);'#13#10'  fSortColumn := 0;'#13#10'  fSortDirection := 1;'#13#10'end'
  +';'#13#10#13#10'destructor TCustomLazProfiler.Destroy;'#13#10'begin'#13#10' '
  ,' fProcList.Free;'#13#10'  fClassList.Free;'#13#10'  fUnitList.Free;'#13#10
  +'  inherited Destroy;'#13#10'end;'#13#10#13#10#13#10'{ TLPStackFrame }'#13#10
  +#13#10'procedure TLPStackFrame.Calc;'#13#10'var'#13#10'  i: Integer;'#13#10
  +'begin'#13#10'  if fNet <> -1 then'#13#10'    exit;'#13#10'  { calc times }'
  +#13#10'  fNet := fTicksEnd - fTicksStart;'#13#10'  fGross := fTicksExit - fT'
  +'icksInit;'#13#10'  fOverhead := fGross - fNet;'#13#10'  { handle Childs }'
  +#13#10'  for i := 0 to fChildList.Count - 1 do begin'#13#10'    fChildList[i'
  +'].Calc;'#13#10'    fNet := fNet - fChildList[i].fGross;'#13#10'    fOverhea'
  +'d := fOverhead + fChildList[i].fOverhead;'#13#10'  end;'#13#10'  FreeAndNil'
  +'(fChildList);'#13#10'  { store infos }'#13#10'  if Assigned(fPasProc) and f'
  +'Running then begin'#13#10'    fPasProc.Count := fPasProc.Count + 1;'#13#10
  +'    fPasProc.fNet := fPasProc.fNet + fNet - fOff;'#13#10'    fPasProc.fGros'
  +'s := fPasProc.fGross + fGross - fOverhead - fOff;'#13#10'  end;'#13#10'end;'
  +#13#10#13#10'procedure TLPStackFrame.CleanupChilds;'#13#10'var'#13#10'  i: I'
  +'nteger;'#13#10'begin'#13#10'  for i := 0 to fChildList.Count - 1 do'#13#10
  +'    fChildList[i].Calc;'#13#10'end;'#13#10#13#10'constructor TLPStackFrame.'
  +'Create(pProc: TLPPasProc; pParent: TLPStackFrame);'#13#10'begin'#13#10'  fP'
  +'asProc := pProc;'#13#10'  fParent := pParent;'#13#10'  if Assigned(fParent)'
  +' then'#13#10'    fParent.fChildList.Add(Self);'#13#10'  fNet := -1;'#13#10
  +'  fGross := -1;'#13#10'  fChildList := TLPStackFrameList.Create;'#13#10'end'
  +';'#13#10#13#10'destructor TLPStackFrame.Destroy;'#13#10'begin'#13#10'  fChi'
  +'ldList.Free;'#13#10'  inherited Destroy;'#13#10'end;'#13#10#13#10#13#10'{ T'
  +'LPPasProcList }'#13#10#13#10'constructor TLPPasProcList.Create(pOwnsObjects'
  +': Boolean);'#13#10'begin'#13#10'  inherited Create(pOwnsObjects);'#13#10'  '
  +'fCallCount := 0;'#13#10'end;'#13#10#13#10'procedure TLPPasProcList.Init;'#13
  +#10'var'#13#10'  i: Integer;'#13#10'begin'#13#10'  for i := 0 to Count -1 do'
  +#13#10'    Items[i].Init;'#13#10'end;'#13#10#13#10'procedure TLPPasProcList.'
  +'Convert(pTicks: ticktype);'#13#10'var'#13#10'  i: Integer;'#13#10'begin'#13
  +#10'  for i := 0 to Count - 1 do begin'#13#10'    Items[i].Net := trunc(Item'
  +'s[i].Net / pTicks * 1000000000);'#13#10'    Items[i].Gross := trunc(Items[i'
  +'].Gross / pTicks * 1000000000);'#13#10'  end;'#13#10'end;'#13#10#13#10'proc'
  +'edure TLPPasProcList.SaveToStringList(pList: TStringList);'#13#10'var'#13#10
  +'  lLine: TStringList;'#13#10'  i: Integer;'#13#10'begin'#13#10'  lLine := T'
  +'StringList.Create;'#13#10'  try'#13#10'    lLine.Delimiter := '';'';'#13#10
  +'    lLine.StrictDelimiter := True;'#13#10'    for i := 0 to Count - 1 do be'
  +'gin'#13#10'      lLine.Clear;'#13#10'      lLine.Add(Items[i].Name);'#13#10
  +'      lLine.Add(IntToStr(Items[i].Kind));'#13#10'      lLine.Add(Items[i].N'
  +'ameOfClass);'#13#10'      lLine.Add(Items[i].UnitName);'#13#10'      lLine.'
  +'Add(Items[i].FileName);'#13#10'      lLine.Add(IntToStr(Items[i].Row));'#13
  +#10'      lLine.Add(IntToStr(Items[i].Count));'#13#10'      lLine.Add(IntToS'
  +'tr(Items[i].Net));'#13#10'      lLine.Add(IntToStr(Items[i].Gross));'#13#10
  +'      lLine.Add(BoolToStr(Items[i].Instrument, True));'#13#10'      pList.A'
  +'dd(lLine.DelimitedText);'#13#10'    end;'#13#10'  finally'#13#10'    lLine.'
  +'Free;'#13#10'  end;'#13#10'end;'#13#10#13#10'function TLPPasProcList.IndexO'
  +'f(pName, pNameOfClass, pUnitName, pFileName: String): SizeInt;'#13#10'var'
  +#13#10'  lPasProc: TLPPasProc;'#13#10'  i: Integer;'#13#10'begin'#13#10'  pN'
  +'ame := UpperCase(pName);'#13#10'  pNameOfClass := UpperCase(pNameOfClass);'
  +#13#10'  pUnitName := UpperCase(pUnitName);'#13#10'  pFileName := UpperCase('
  +'pFileName);'#13#10'  for i := 0 to Count - 1 do begin'#13#10'    lPasProc :'
  +'= Self[i];'#13#10'    if (lPasProc.NameUp = pName)'#13#10'    and (lPasProc'
  +'.NameOfClassUp = pNameOfClass)'#13#10'    and (lPasProc.UnitNameUp = pUnitN'
  +'ame)'#13#10'    and (lPasProc.FileNameUp = pFileName) then'#13#10'      Exi'
  +'t(i);'#13#10'  end;'#13#10'  Result := -1;'#13#10'end;'#13#10#13#10'procedu'
  +'re TLPPasProcList.LoadFromStringList(pList: TStringList; pVersion: Integer)'
  +';'#13#10'var'#13#10'  lLine: TStringList;'#13#10'  i: Integer;'#13#10'begin'
  +#13#10'  lLine := TStringList.Create;'#13#10'  try'#13#10'    lLine.Delimite'
  +'r := '';'';'#13#10'    lLine.StrictDelimiter := True;'#13#10'    if pList.C'
  +'ount = 0 then'#13#10'      exit;'#13#10'    for i := 0 to pList.Count - 1 d'
  +'o begin'#13#10'      lLine.DelimitedText := pList[i];'#13#10'      if lLine'
  +'.Count >= 9 then begin'#13#10'        if pVersion = 1 then begin'#13#10'   '
  +'       Add(TLPPasProc.Create(lLine[0], 0, lLine[1], lLine[2], lLine[3], Str'
  +'ToInt(lLine[4])));'#13#10'          Last.Count := StrToInt(lLine[5]);'#13#10
  +'          Last.Net := StrToQWord(lLine[6]);'#13#10'          Last.Gross := '
  +'StrToQWord(lLine[7]);'#13#10'          Last.Instrument := StrToBool(lLine[8'
  ,']);'#13#10'        end else begin'#13#10'          Add(TLPPasProc.Create(lL'
  +'ine[0], StrToInt(lLine[1]), lLine[2], lLine[3], lLine[4], StrToInt(lLine[5]'
  +')));'#13#10'          Last.Count := StrToInt(lLine[6]);'#13#10'          La'
  +'st.Net := StrToQWord(lLine[7]);'#13#10'          Last.Gross := StrToQWord(l'
  +'Line[8]);'#13#10'          Last.Instrument := StrToBool(lLine[9]);'#13#10' '
  +'       end;'#13#10'        //if not Last.Instrument then'#13#10'        // '
  +' DebugLn(''*** do not instrument ''+Last.Name);'#13#10'      end;'#13#10'  '
  +'  end;'#13#10'  finally'#13#10'    lLine.Free;'#13#10'  end;'#13#10'end;'#13
  +#10#13#10#13#10'{ TLazProfiler }'#13#10#13#10'function TLazProfiler.GetOffTi'
  +'cks: TickType;'#13#10'begin'#13#10'  if fPauseCount = 0 then begin'#13#10' '
  +'   Result := fOffTicks;'#13#10'    fOffTicks := 0;'#13#10'  end else'#13#10
  +'    Result := 0;'#13#10'end;'#13#10#13#10'function TLazProfiler.HWTicks: Ti'
  +'cktype;'#13#10'begin'#13#10'  Result := fTimer.HWTimebase.Ticks() - fTimer.'
  +'HWTimebase.TicksOverhead;'#13#10'end;'#13#10#13#10'function TLazProfiler.Sy'
  +'sTicks: Ticktype;'#13#10'begin'#13#10'  Result := fTimer.SysTimebase.Ticks('
  +') - fTimer.SysTimebase.TicksOverhead;'#13#10'end;'#13#10#13#10'function TLa'
  +'zProfiler.ThreadIndex(pThread: TThreadID): Integer;'#13#10'var'#13#10'  lCu'
  +'rStackFrame: TLPStackFrame;'#13#10'begin'#13#10'  Result := fThreads.IndexO'
  +'f(Pointer(pThread));'#13#10'  if Result = -1 then begin'#13#10'    Result :'
  +'= fThreads.Add(Pointer(pThread));'#13#10'    if fThreads.Count > Length(fCu'
  +'rStackFrame) then'#13#10'      SetLength(fCurStackFrame, fThreads.Count + 1'
  +'00);'#13#10'    lCurStackFrame := TLPStackFrame.Create(fMasterProc, nil);'
  +#13#10'    lCurStackFrame.fTicksInit := Ticks();'#13#10'    lCurStackFrame.f'
  +'TicksStart := lCurStackFrame.fTicksInit;'#13#10'    fCurStackFrame[Result] '
  +':= lCurStackFrame;'#13#10'  end;'#13#10'end;'#13#10#13#10'procedure TLazPro'
  +'filer.Lock;'#13#10'begin'#13#10'  EnterCriticalsection(fLock);'#13#10'end;'
  +#13#10#13#10'procedure TLazProfiler.UnLock;'#13#10'begin'#13#10'  LeaveCriti'
  +'calsection(fLock);'#13#10'end;'#13#10#13#10'procedure TLazProfiler.EnterPro'
  +'filing(pProcID: Integer);'#13#10'var'#13#10'  lTimeStamp: TickType;'#13#10
  +'  lCurStackFrame: TLPStackFrame;'#13#10'  lIdx: Integer;'#13#10'begin'#13#10
  +'  lTimeStamp := Ticks();'#13#10'  Lock;'#13#10'  try'#13#10'    if pProcID '
  +'>= fProcList.Count then begin'#13#10'      ShowMessage(''TLazProfiler.Enter'
  +'Profiling: pProcID >= fProcList.Count: ''+IntToStr(pProcID)+''>=''+IntToStr'
  +'(fProcList.Count));'#13#10'      Exit;'#13#10'    end;'#13#10'    lIdx := T'
  +'hreadIndex(ThreadID);'#13#10'    lCurStackFrame := fCurStackFrame[lIdx];'#13
  +#10'    lCurStackFrame := TLPStackFrame.Create(fProcList[pProcID], lCurStack'
  +'Frame);'#13#10'    fCurStackFrame[lIdx] := lCurStackFrame;'#13#10'    lCurS'
  +'tackFrame.fRunning := fRunning;'#13#10'    lCurStackFrame.fTicksInit := lTi'
  +'meStamp;'#13#10'  finally'#13#10'    UnLock;'#13#10'  end;'#13#10'  lCurSta'
  +'ckFrame.fTicksStart := Ticks();'#13#10'end;'#13#10#13#10'procedure TLazProf'
  +'iler.ExitProfiling(pProcID: Integer);'#13#10'var'#13#10'  lTimeStamp: TickT'
  +'ype;'#13#10'  lCurStackFrame: TLPStackFrame;'#13#10'  lIdx: Integer;'#13#10
  +'begin'#13#10'  lTimeStamp := Ticks();'#13#10'  Lock;'#13#10'  try'#13#10'  '
  +'  lIdx := ThreadIndex(ThreadID);'#13#10'    lCurStackFrame := fCurStackFram'
  +'e[lIdx];'#13#10'    lCurStackFrame.fTicksEnd := lTimeStamp;'#13#10'    if p'
  +'ProcID >= fProcList.Count then begin'#13#10'      ShowMessage(''TLazProfile'
  +'r.ExitProfiling: pProcID >= fProcList.Count: ''+IntToStr(pProcID)+''>=''+In'
  +'tToStr(fProcList.Count));'#13#10'      Exit;'#13#10'    end;'#13#10'    if '
  +'lCurStackFrame.fPasProc <> fProcList[pProcID] then'#13#10'      ShowMessage'
  +'(''TLazProfiler.ExitProfiling: Stack mismatch: ''+lCurStackFrame.fPasProc.N'
  +'ame+''<->''+fProcList[pProcID].name);'#13#10'    lCurStackFrame.fOff := Off'
  +'Ticks;'#13#10'    lCurStackFrame.CleanupChilds;'#13#10'    fCurStackFrame[l'
  +'Idx] := lCurStackFrame.fParent;'#13#10'  finally'#13#10'    UnLock;'#13#10
  +'  end;'#13#10'  lCurStackFrame.fTicksExit := Ticks();'#13#10'end;'#13#10#13
  +#10'procedure TLazProfiler.StartProfiling;'#13#10'begin'#13#10'  fRunning :='
  +' True;'#13#10'  DebugLn(''### LazProfiler: Start'');'#13#10'end;'#13#10#13
  +#10'procedure TLazProfiler.PauseProfiling;'#13#10'begin'#13#10'  if fPauseCo'
  +'unt = 0 then'#13#10'    fPauseStartTicks := Ticks();'#13#10'  inc(fPauseCou'
  +'nt);'#13#10'end;'#13#10#13#10'procedure TLazProfiler.ContinueProfiling;'#13
  +#10'begin'#13#10'  dec(fPauseCount);'#13#10'  if fRunning then begin'#13#10
  +'    if fPauseCount = 0 then begin'#13#10'      if fPauseStartTicks <> 0 the'
  +'n'#13#10'        fOffTicks := fOffTicks + (Ticks() - fPauseStartTicks)'#13
  +#10'      else'#13#10'        fOffTicks := 0;'#13#10'      fPauseStartTicks '
  +':= 0;'#13#10'    end;'#13#10'  end else begin'#13#10'    fOffTicks := 0;'#13
  ,#10'    fPauseStartTicks := 0;'#13#10'  end;'#13#10'end;'#13#10#13#10'proced'
  +'ure TLazProfiler.StopProfiling;'#13#10'begin'#13#10'  fRunning := False;'#13
  +#10'  DebugLn(''### LazProfiler: Stop'');'#13#10'end;'#13#10#13#10'construct'
  +'or TLazProfiler.Create(pProgramm: String);'#13#10'var'#13#10'  lCurStackFra'
  +'me: TLPStackFrame;'#13#10'begin'#13#10'  inherited Create;'#13#10'  InitCri'
  +'ticalSection(fLock);'#13#10'  fName := AppendPathDelim(ExtractFileDir(pProg'
  +'ramm))+ExtractFileNameOnly(pProgramm);'#13#10'  fTimer := TEpikTimer.Create'
  +'(nil);'#13#10'  if fTimer.HWCapabilityDataAvailable and fTimer.HWTickSuppor'
  +'tAvailable then begin'#13#10'    Ticks := @HWTicks;'#13#10'    fTicks := fT'
  +'imer.HWTimebase.TicksFrequency;'#13#10'    DebugLn(''### LazProfiler: HWTic'
  +'ks used. Freq=''+IntToStr(fTicks));'#13#10'  end else begin'#13#10'    Tick'
  +'s := @SysTicks;'#13#10'    fTicks := fTimer.SysTimebase.TicksFrequency;'#13
  +#10'    DebugLn(''### LazProfiler: SysTicks used. Freq=''+IntToStr(fTicks));'
  +#13#10'  end;'#13#10'  fMasterProc := TLPPasProc.Create(''Master'', 0, '''','
  +' '''', '''', -1);'#13#10'  fOffTicks := 0;'#13#10'  fThreads := TList.Creat'
  +'e;'#13#10'  lCurStackFrame := TLPStackFrame.Create(fMasterProc, nil);'#13#10
  +'  lCurStackFrame.fTicksInit := Ticks();'#13#10'  lCurStackFrame.fTicksStart'
  +' := lCurStackFrame.fTicksInit;'#13#10'  SetLength(fCurStackFrame, 100);'#13
  +#10'  fCurStackFrame[fThreads.Add(Pointer(ThreadID))] := lCurStackFrame;'#13
  +#10'  fLoaded := LoadFromFile(fName+cSettingExtension);'#13#10'  fRunning :='
  +' fAutoStart;'#13#10'end;'#13#10#13#10'destructor TLazProfiler.Destroy;'#13
  +#10'var'#13#10'  i: Integer;'#13#10'  lCurStackFrame: TLPStackFrame;'#13#10
  +'begin'#13#10'  fMasterProc.Free;'#13#10'  for i := 0 to fThreads.Count - 1 '
  +'do begin'#13#10'    lCurStackFrame := fCurStackFrame[i];'#13#10'    lCurSta'
  +'ckFrame.fTicksEnd := Ticks();'#13#10'    lCurStackFrame.fTicksExit := lCurS'
  +'tackFrame.fTicksEnd;'#13#10'    lCurStackFrame.Calc;'#13#10'    lCurStackFr'
  +'ame.Free;'#13#10'  end;'#13#10'  { calc percentages }'#13#10#13#10'  { free'
  +' resources }'#13#10'  fThreads.Free;'#13#10'  SetLength(fCurStackFrame, 0);'
  +#13#10'  fTimer.Free;'#13#10'  if fTicks > 0 then'#13#10'    fProcList.Conve'
  +'rt(fTicks)'#13#10'  else'#13#10'    DebugLn(''***** LazProfiler: fTicks=''+'
  +'IntToStr(fTicks));'#13#10'  if fLoaded then'#13#10'    SaveToFile(fName+cSe'
  +'ttingExtension);'#13#10'  DoneCriticalSection(fLock);'#13#10'  inherited De'
  +'stroy;'#13#10'end;'#13#10#13#10#13#10'{ TLPPasProc }'#13#10#13#10'procedure'
  +' TLPPasProc.Init;'#13#10'begin'#13#10'  fCount := 0;'#13#10'  fNet := 0;'#13
  +#10'  fGross := 0;'#13#10'end;'#13#10#13#10'procedure TLPPasProc.SetFileName'
  +'(pFileName: String);'#13#10'begin'#13#10'  if fFileName = pFileName then Ex'
  +'it;'#13#10'  fFileName := pFileName;'#13#10'  fFileNameUp := UpperCase(fFil'
  +'eName);'#13#10'end;'#13#10#13#10'procedure TLPPasProc.SetName(pName: String'
  +');'#13#10'begin'#13#10'  if fName = pName then Exit;'#13#10'  fName := pNam'
  +'e;'#13#10'  fNameUp := UpperCase(pName);'#13#10'end;'#13#10#13#10'construct'
  +'or TLPPasProc.Create(pName: String; pKind: Integer; pNameOfClass, pUnitName'
  +', pFileName: String; pRow: Integer);'#13#10'begin'#13#10'  inherited Create'
  +'(pNameOfClass, pUnitName, pFileName);'#13#10'  fName := pName;'#13#10'  fNa'
  +'meUp := UpperCase(pName);'#13#10'  fRow := pRow;'#13#10'  fInstrument := Tr'
  +'ue;'#13#10'  fKind := pKind;'#13#10'  Init;'#13#10'end;'#13#10#13#10'destru'
  +'ctor TLPPasProc.Destroy;'#13#10'begin'#13#10'  fCalls.Free;'#13#10'  fCalle'
  +'dBy.Free;'#13#10'  fCallsCount.Free;'#13#10'  fCalledByCount.Free;'#13#10' '
  +' inherited Destroy;'#13#10'end;'#13#10#13#10'procedure TLPPasProc.Calls(pPr'
  +'oc: TLPPasProc);'#13#10'var'#13#10'  i: SizeInt;'#13#10'begin'#13#10'  if n'
  +'ot Assigned(fCalls) then begin'#13#10'    fCalls := TLPPasProcList.Create(F'
  +'alse);'#13#10'    fCallsCount := TIntegerList.Create;'#13#10'  end;'#13#10
  +'  i := fCalls.IndexOf(pProc);'#13#10'  if i = -1 then begin'#13#10'    fCal'
  +'ls.Add(pProc);'#13#10'    fCallsCount.Add(1);'#13#10'  end else begin'#13#10
  +'    fCallsCount[i] := fCallsCount[i] + 1;'#13#10'  end;'#13#10'end;'#13#10
  +#13#10'procedure TLPPasProc.CalledBy(pProc: TLPPasProc);'#13#10'var'#13#10' '
  +' i: SizeInt;'#13#10'begin'#13#10'  if not Assigned(fCalledBy) then begin'#13
  +#10'    fCalledBy := TLPPasProcList.Create(False);'#13#10'    fCalledByCount'
  +' := TIntegerList.Create;'#13#10'  end;'#13#10'  i := fCalledBy.IndexOf(pPro'
  +'c);'#13#10'  if i = -1 then begin'#13#10'    fCalledBy.Add(pProc);'#13#10' '
  +'   fCalledByCount.Add(1);'#13#10'  end else begin'#13#10'    fCalledByCount'
  +'[i] := fCalledByCount[i] + 1;'#13#10'  end;'#13#10'end;'#13#10#13#10'end.'
  +#13#10#13#10
]);
LazarusResources.Add('timer','PAS',[
  'unit EpikTimer;'#10#10'{ Name: EpikTimer'#10'  Description: Precision timer/'
  +'stopwatch component for Lazarus/FPC'#10'  Author: Tom Lisjac <netdxr@gmail.'
  +'com>'#10'  Started on: June 24, 2003'#10'  Features:'#10'    Dual selectabl'
  +'e timebases: Default:System (uSec timeofday or "now" in Win32)'#10'        '
  +'                       Optional: Pentium Time Stamp Counter.'#10'    Defaul'
  +'t timebase should work on most Unix systems of any architecture.'#10'    Ti'
  +'mebase correlation locks time stamp counter accuracy to system clock.'#10' '
  +'   Timers can be started, stopped, paused and resumed.'#10'    Unlimited nu'
  +'mber of timers can be implemented with one component.'#10'    Low resources'
  +' required: 25 bytes per timer; No CPU overhead.'#10'    Internal call overh'
  +'ead compensation.'#10'    System sleep function'#10'    Designed to support'
  +' multiple operating systems and Architectures'#10'    Designed to support o'
  +'ther hardware tick sources'#10'            '#10'  Credits: Thanks to Martin'
  +' Waldenburg for a lot of great ideas for using'#10'           the Pentium'''
  +'s RDTSC instruction in wmFastTime and QwmFastTime.'#10'}'#10#10'{ Copyright'
  +' (C) 2003-2006 by Tom Lisjac <netdxr@gmail.com>,'#10'   Felipe Monteiro de '
  +'Carvalho and Marcel Minderhoud'#10#10'  This library is licensed on the sam'
  +'e Modifyed LGPL as Free Pascal RTL and LCL are'#10#10'  Please contact the '
  +'author if you''d like to use this component but the Modifyed LGPL'#10'  doe'
  +'sn''t work with your project licensing.'#10#10'  This program is distribute'
  +'d in the hope that it will be useful, but WITHOUT'#10'  ANY WARRANTY; witho'
  +'ut even the implied warranty of MERCHANTABILITY or'#10'  FITNESS FOR A PART'
  +'ICULAR PURPOSE.'#10'  '#10'  Contributor(s):'#10'  '#10'  * Felipe Monteiro'
  +' de Carvalho (felipemonteiro.carvalho@gmail.com)'#10'  '#10'  * Marcel Mind'
  +'erhoud'#10'  '#10'}'#10'{'#10' Known Issues'#10#10'   - Tested on Linux but'
  +' no other Lazarus/FPC supported Unix platforms'#10'   - If system doesn''t '
  +'have microsecond system clock resolution, the component'#10'     falls back'
  +' to a single gated measurement of the hardware tick frequency via'#10'     '
  +'nanosleep. This usually results in poor absolute accuracy due large amounts'
  +#10'     of jitter in nanosleep... but for typical short term measurements, '
  +'this'#10'     shouldn''t be a problem.'#10#10'}'#10#10'{$IFDEF FPC}'#10'  {'
  +'$MODE DELPHI}{$H+}'#10'{$ENDIF}'#10#10'{$IFNDEF FPC}'#10'  {$DEFINE Windows'
  +'}'#10'{$ENDIF}'#10#10'{$IFDEF Win32}'#10'  {$DEFINE Windows}'#10'{$ENDIF}'
  +#10#10'interface'#10#10'uses'#10'{$IFDEF Windows}'#10'  Windows, MMSystem,'
  +#10'{$ELSE}'#10'  unix, unixutil, BaseUnix,'#10'{$ENDIF}'#10'  Classes, SysU'
  +'tils, dateutils;'#10#10'Const'#10'  DefaultSystemTicksPerSecond = 1000000; '
  +'//Divisor for microsecond resolution'#10'  { HW Tick frequency falls back t'
  +'o gated measurement if the initial system'#10'    clock measurement is outs'
  +'ide this range plus or minus.}'#10'  SystemTicksNormalRangeLimit = 100000;'
  +#10#10'type'#10#10'  TickType = Int64; // Global declaration for all tick pr'
  +'ocessing routines'#10'  '#10'  FormatPrecision = 1..12; // Number of decima'
  +'l places in elapsed text format'#10'  '#10'  // Component powers up in Syst'
  +'em mode to provide some cross-platform safety.'#10'  TickSources = (SystemT'
  +'imebase, HardwareTimebase); // add others if desired'#10#10'  (* * * * * * '
  +'* * * * * Timebase declarations  * * * * * * * * * * *)'#10'  '#10'  { Ther'
  +'e are two timebases currently implemented in this component but others'#10
  +'    can be added by declaring them as "TickSources", adding a TimebaseData'
  +#10'    variable to the Private area of TEpikTimer and providing a "Ticks" r'
  +'outine'#10'    that returns the current counter value.'#10'    '#10'    Tim'
  +'ebases are "calibrated" during initialization by taking samples of the'#10
  +'    execution times of the SystemSleep and Ticks functions measured with in'
  +' the'#10'    tick period of the selected timebase. At runtime, these values'
  +' are retrieved'#10'    and used to remove the call overhead to the best deg'
  +'ree possible.'#10'    '#10'    System latency is always present and contrib'
  +'utes "jitter" to the edges of'#10'    the sample measurements. This is espe'
  +'cially true if a microsecond system'#10'    clock isn''t detected on the ho'
  +'st system and a fallback gated measurement'#10'    (based on nanosleep in L'
  +'inux and sleep in Win32) is used to determine the'#10'    timebase frequenc'
  +'y. This is sufficient for short term measurements where'#10'    high resolu'
  +'tion comparisons are desired... but over a long measurement'#10'    period,'
  +' the hardware and system wall clock will diverge significantly.'#10'    '#10
  +'    If a microsecond system clock is found, timebase correlation is used to'
  +#10'    synchronize the hardware counter and system clock. This is described'
  +' below.'#10'  }'#10#10'  TickCallFunc = function: Ticktype; // Ticks interf'
  ,'ace function'#10'  '#10'  // Contains timebase overhead compensation factor'
  +'s in ticks for each timebase'#10'  TimebaseCalibrationParameters = record'
  +#10'    FreqCalibrated: Boolean; // Indicates that the tickfrequency has bee'
  +'n calibrated'#10'    OverheadCalibrated: Boolean; // Indicates that all cal'
  +'l overheads have been calibrated'#10'    TicksIterations: Integer; // numbe'
  +'r of iterations to use when measuring ticks overhead'#10'    SleepIteration'
  +'s: Integer; // number of iterations to use when measuring SystemSleep overh'
  +'ead'#10'    FreqIterations: Integer;  // number of iterations to use when m'
  +'easuring ticks frequency'#10'    FrequencyGateTimeMS: Integer;  // gate tim'
  +'e to use when measuring ticks frequency'#10'   end;'#10#10'  // This record'
  +' defines the Timebase context'#10'  TimebaseData = record'#10'    Calibrati'
  +'onParms: TimebaseCalibrationParameters; // Calibration data for this timeba'
  +'se'#10'    TicksFrequency: TickType; // Tick frequency of this timebase'#10
  +'    TicksOverhead: Ticktype;  // Ticks call overhead in TicksFrequency for '
  +'this timebase'#10'    SleepOverhead: Ticktype;   // SystemSleep all overhea'
  +'d in TicksFrequency for this timebase'#10'    Ticks: TickCallFunc; // all m'
  +'ethods get their ticks from this function when selected'#10'  end;'#10'  '
  +#10'  TimeBaseSelector = ^TimebaseData;'#10'  '#10'  (*  * * * * * * * * * *'
  +' Timebase Correlation  * * * * * * * * * * *)'#10#10'  { The TimeBaseCorrel'
  +'ation record stores snapshot samples of both the system'#10'    ticks (the '
  +'source of known accuracy) and the hardware tick source (the'#10'    source '
  +'of high measurement resolution). An initial sample is taken at power'#10'  '
  +'  up. The CorrelationMode property sets where and when updates are acquired'
  +'.'#10#10'    When an update snapshot is acquired, the differences between i'
  +'t and the'#10'    startup value can be used to calculate the hardware clock'
  +' frequency with'#10'    high precision from the accuracy of the accumulated'
  +' system clocks. The'#10'    longer time that elapses between startup and a '
  +'call to "CorrelateTimebases",'#10'    the better the accuracy will be. On a'
  +' 1.6 Ghz P4, it only takes a few'#10'    seconds to achieve measurement cer'
  +'tainty down to a few Hertz.'#10#10'    Of course this system is only as goo'
  +'d as your system clock accuracy, so'#10'    it''s a good idea to periodical'
  +'ly sync it with NTP or against another source'#10'    of known accuracy if '
  +'you want to maximize the long term of the timers. }'#10#10'  TimebaseCorrel'
  +'ationData = record'#10'    SystemTicks: TickType;'#10'    HWTicks: TickType'
  +';'#10'  end;'#10#10'  // If the Correlation property is set to automatic, a'
  +'n update sample is taken'#10'  // anytime the user calls Start or Elapsed. '
  +'If in manual, the correlation'#10'  // update is only done when "CorrelateT'
  +'imebases" is called. Doing updates'#10'  // with every call adds a small am'
  +'ount of overhead... and after the first few'#10'  // minutes of operation, '
  +'there won''t be very much correcting to do!'#10#10'  CorrelationModes=(Manu'
  +'al, OnTimebaseSelect, OnGetElapsed);'#10'  '#10'  (* * * * * * * * * * * Ti'
  +'mer Data record structure  * * * * * * * * * * *)'#10'  '#10'  // This is t'
  +'he timer data context. There is an internal declaration of this'#10'  // re'
  +'cord and overloaded methods if you only want to use the component for a'#10
  +'  // single timer... or you can declare multiple TimerData records in your'
  +#10'  // program and create as many instances as you want with only a single'
  +#10'  // component on the form. See the "Stopwatch" methods in the TEpikTime'
  +'r class.'#10'  '#10'  // Each timers points to the timebase that started it'
  +'... so you can mix system'#10'  // and hardware timers in the same applicat'
  +'ion.'#10#10'  TimerData = record'#10'    Running:Boolean; // Timer is curre'
  +'ntly running'#10'    TimebaseUsed:TimeBaseSelector; // keeps timer aligned '
  +'with the source that started it.'#10'    StartTime:TickType; // Ticks sampl'
  +'e when timer was started'#10'    TotalTicks:TickType; // Total ticks... for'
  +' snapshotting and pausing'#10'  end;'#10'  '#10'  TEpikTimer= class(TCompon'
  +'ent)'#10'    private'#10'      BuiltInTimer:TimerData; // Used to provide a'
  +' single built-in timer;'#10'      FHWTickSupportAvailable:Boolean; // True '
  +'if hardware tick support is available'#10'      FHWCapabilityDataAvailable:'
  +'Boolean; // True if hardware tick support is available'#10'      FHWTicks:T'
  +'imeBaseData;     // The hardware timebase'#10'      FSystemTicks:TimeBaseDa'
  +'ta; // The system timebase'#10'      FSelectedTimebase:TimeBaseSelector; //'
  +' Pointer to selected database'#10'      '#10'      FTimeBaseSource: TickSou'
  +'rces; // use hardware or system timebase'#10'      FWantDays: Boolean; // t'
  +'rue if days are to be displayed in string returns'#10'      FWantMS: Boolea'
  +'n; // True to display milliseconds in string formatted calls'#10'      FSPr'
  ,'ecision: FormatPrecision; // number of digits to display in string calls'#10
  +'      FMicrosecondSystemClockAvailable:Boolean; // true if system has micro'
  +'second clock'#10'      '#10'      StartupCorrelationSample:TimebaseCorrelat'
  +'ionData; // Starting ticks correlation snapshot'#10'      UpdatedCorrelatio'
  +'nSample:TimebaseCorrelationData; // Snapshot of last correlation sample'#10
  +'      FCorrelationMode: CorrelationModes; // mode to control when correlati'
  +'on updates are performed'#10'    protected'#10'      function GetSelectedTi'
  +'mebase: TimebaseData;'#10'      procedure SetSelectedTimebase(const AValue:'
  +' TimebaseData);'#10'      procedure SetTimebaseSource(const AValue: TickSou'
  +'rces); //setter for TB'#10'      Procedure GetCorrelationSample(Var Correla'
  +'tionData:TimeBaseCorrelationData);'#10'    public'#10'      {              '
  +'         Stopwatch emulation routines'#10'        These routines behave exa'
  +'ctly like a conventional stopwatch with start,'#10'        stop, elapsed (l'
  +'ap) and clear methods. The timers can be started,'#10'        stopped and r'
  +'esumed. The Elapsed routines provide a "lap" time analog.'#10#10'        Th'
  +'e methods are overloaded to make it easy to simply use the component''s'#10
  +'        BuiltInTimer as a single timer... or to declare your own TimerData '
  +'records'#10'        in order to implement unlimited numbers of timers using'
  +' a single component'#10'        on the form. The timers are very resource e'
  +'fficient because they consume'#10'        no CPU overhead and only require '
  +'about 25 bytes of memory.'#10'      }'#10#10'      // Stops and resets the '
  +'timer'#10'      procedure Clear; overload;// Call this routine to use the b'
  +'uilt-in timer record'#10'      procedure Clear(Var T:TimerData); overload; '
  +'// pass your TimerData record to this one'#10#10'      //Start or resume a '
  +'stopped timer'#10'      procedure Start; overload;'#10'      procedure Star'
  +'t(Var T:TimerData); overload;'#10#10'      //Stop or pause a timer'#10'    '
  +'  procedure Stop; overload;'#10'      procedure Stop(Var T:TimerData); over'
  +'load;'#10#10'      //Return elapsed time in seconds as an extended type'#10
  +'      function Elapsed:Extended; overload;'#10'      function Elapsed(var T'
  +': TimerData):Extended; overload;'#10#10'      //Return a string in Day:Hour'
  +':Minute:Second format. Milliseconds can be'#10'      //optionally appended '
  +'via the WantMilliseconds property'#10'      function ElapsedDHMS:String; ov'
  +'erload;'#10'      function ElapsedDHMS(var T: TimerData):String; overload;'
  +#10#10'      //Return a string in the format of seconds.milliseconds'#10'   '
  +'   function ElapsedStr:String; overload;'#10'      function ElapsedStr(var '
  +'T:TimerData):String; overload;'#10#10'      function WallClockTime:String; '
  +'// Return time of day string from system time'#10#10'      //Overhead compe'
  +'nsated system sleep to provide a best possible precision delay'#10'      fu'
  +'nction SystemSleep(Milliseconds: Integer):integer; Virtual;'#10#10'      //'
  +'Diagnostic taps for development and fine grained timebase adjustment'#10'  '
  +'    property HWTimebase: TimeBaseData read FHWTicks write FHWTicks; // The '
  +'hardware timebase'#10'      property SysTimebase: TimebaseData read FSystem'
  +'Ticks write FSystemTicks;'#10'      function GetHardwareTicks:TickType; // '
  +'return raw tick value from hardware source'#10'      function GetSystemTick'
  +'s:Ticktype;   // Return system tick value(in microseconds of Epoch time)'#10
  +'      function GetTimebaseCorrelation:TickType;'#10'      function Calibrat'
  +'eCallOverheads(Var TimeBase:TimebaseData) : Integer; Virtual;'#10'      fun'
  +'ction CalibrateTickFrequency(Var TimeBase:TimebaseData): Integer; Virtual;'
  +#10#10'      property MicrosecondSystemClockAvailable:Boolean read FMicrosec'
  +'ondSystemClockAvailable;'#10'      property SelectedTimebase:TimebaseSelect'
  +'or read FSelectedTimebase write FSelectedTimebase;'#10'      property HWTic'
  +'kSupportAvailable:Boolean read FHWTickSupportAvailable;'#10'      property '
  +'HWCapabilityDataAvailable:Boolean read FHWCapabilityDataAvailable;'#10'    '
  +'  procedure CorrelateTimebases; // Manually call to do timebase correlation'
  +' snapshot and update'#10#10'      constructor Create(AOwner:TComponent); Ov'
  +'erride;'#10'      destructor Destroy; Override;'#10'    Published'#10'     '
  +' property StringPrecision: FormatPrecision read FSPrecision write FSPrecisi'
  +'on;'#10'      property WantMilliseconds: Boolean read FWantMS write FWantMS'
  +';'#10'      property WantDays: Boolean read FWantDays write FWantDays;'#10
  +'      property TimebaseSource: TickSources read FTimeBaseSource write SetTi'
  +'mebaseSource;'#10'      property CorrelationMode:CorrelationModes read FCor'
  +'relationMode write FCorrelationMode;'#10'  end;'#10#10#10'implementation'#10
  +#10'(* * * * * * * * * * * * * * Timebase Section  * * * * * * * * * * * * *'
  +')'#10'{'#10'  There are two tick sources defined in this section. The first'
  ,' uses a hardware'#10'  source which, in this case, is the Pentium''s intern'
  +'al 64 Time Stamp Counter.'#10'  The second source (the default) uses the gi'
  +'ven environment''s most precision'#10'  "timeofday" system call so it can w'
  +'ork across OS platforms and architectures.'#10'  '#10'  The hardware timer'
  +'''s accuracy depends on the frequency of the timebase tick'#10'  source tha'
  +'t drives it... in other words, how many of the timebase''s ticks'#10'  ther'
  +'e are in a second. This frequency is measured by capturing a sample of the'
  +#10'  timebase ticks for a known period against a source of known accuracy. '
  +'There'#10'  are two ways to do this.'#10'  '#10'  The first is to capture a'
  +' large sample of ticks from both the unknown and'#10'  known timing sources'
  +'. Then the frequency of the unknown tick stream can be'#10'  calculated by:'
  +' UnknownSampleTicks / (KnownSampleTicks / KnownTickFrequency).'#10'  Over a'
  +' short period of time, this can provide a precise synchronization'#10'  mec'
  +'hanism that effectively locks the measurements taken with the high'#10'  re'
  +'solution source to the known accuracy of the system clock.'#10#10'  The fir'
  +'st method depends on the existance of an accurate system time source of'#10
  +'  microsecond resolution. If the host system doesn''t provide this, the sec'
  +'ond'#10'  fallback method is to gate the unknown tick stream by a known tim'
  +'e. This isn''t'#10'  as good because it usually involves calling a system "'
  +'delay" routine that'#10'  usually has a lot of overhead "jitter" and non-de'
  +'terministic behavior. This'#10'  approach is usable, however, for short ter'
  +'m, high resolution comparisons where'#10'  absolute accuracy isn''t importa'
  +'nt.'#10'}'#10#10'(* * * * * * * * Start of i386 Hardware specific code  * *'
  +' * * * * *)'#10#10'{$IFDEF CPUI386}'#10'{ Some references for this section '
  +'can be found at:'#10'      http://www.sandpile.org/ia32/cpuid.htm'#10'     '
  +' http://www.sandpile.org/ia32/opc_2.htm'#10'      http://www.sandpile.org/i'
  +'a32/msr.htm'#10'}'#10#10'// Pentium specific... push and pop the flags and '
  +'check for CPUID availability'#10'function HasHardwareCapabilityData: Boolea'
  +'n;'#10'begin'#10'  asm'#10'   PUSHFD'#10'   POP    EAX'#10'   MOV    EDX,EA'
  +'X'#10'   XOR    EAX,$200000'#10'   PUSH   EAX'#10'   POPFD'#10'   PUSHFD'#10
  +'   POP    EAX'#10'   XOR    EAX,EDX'#10'   JZ     @EXIT'#10'   MOV    AL,TR'
  +'UE'#10'   @EXIT:'#10'  end;'#10'end;'#10#10'function HasHardwareTickCounter'
  +': Boolean;'#10'  var FeatureFlags: Longword;'#10'  begin'#10'    FeatureFla'
  +'gs:=0;'#10'    asm'#10'      PUSH   EBX'#10'      XOR    EAX,EAX'#10'      '
  +'DW     $A20F'#10'      POP    EBX'#10'      CMP    EAX,1'#10'      JL     @'
  +'EXIT'#10'      XOR    EAX,EAX'#10'      MOV    EAX,1'#10'      PUSH   EBX'
  +#10'      DW     $A20F'#10'      MOV    FEATUREFLAGS,EDX'#10'      POP    EB'
  +'X'#10'      @EXIT:'#10'    end;'#10'    Result := (FeatureFlags and $10) <>'
  +' 0;'#10'  end;'#10#10'// Execute the Pentium''s RDTSC instruction to access'
  +' the counter value.'#10'function HardwareTicks: TickType; assembler; asm DW'
  +' 0310FH end;'#10#10'(* * * * * * * * End of i386 Hardware specific code  * '
  +'* * * * * *)'#10#10#10'// These are here for architectures that don''t have'
  +' a precision hardware'#10'// timing source. They''ll return zeros for overh'
  +'ead values. The timers'#10'// will work but there won''t be any error compe'
  +'nsation for long'#10'// term accuracy.'#10'{$ELSE} // add other architectur'
  +'es and hardware specific tick sources here'#10'function HasHardwareCapabili'
  +'tyData: Boolean; begin Result:=False end;'#10'function HasHardwareTickCount'
  +'er: Boolean; begin Result:=false end;'#10'function HardwareTicks:TickType; '
  +'begin result:=0 end;'#10'{$ENDIF}'#10#10'function NullHardwareTicks:TickTyp'
  +'e; begin Result:=0 end;'#10#10'// Return microsecond normalized time source'
  +' for a given platform.'#10'// This should be sync''able to an external time'
  +' standard (via NTP, for example).'#10'function SystemTicks: TickType;'#10'{'
  +'$IFDEF Windows}'#10'begin'#10'  QueryPerformanceCounter(Result);'#10'  //Re'
  +'sult := Int64(TimeStampToMSecs(DateTimeToTimeStamp(Now)) * 1000) // an alte'
  +'rnative Win32 timebase'#10'{$ELSE}'#10'var t : timeval;'#10'begin'#10'  fpg'
  +'ettimeofday(@t,nil);'#10'   // Build a 64 bit microsecond tick from the sec'
  +'onds and microsecond longints'#10'  Result := (TickType(t.tv_sec) * 1000000'
  +') + t.tv_usec;'#10'{$ENDIF}'#10'end;'#10#10'function TEpikTimer.SystemSleep'
  +'(Milliseconds: Integer):Integer;'#10'{$IFDEF Windows}'#10#10'begin'#10'  Sl'
  +'eep(Milliseconds);'#10'  Result := 0;'#10'end;'#10#10'{$ELSE}'#10#10'  {$IF'
  +'DEF CPUX86_64}'#10#10'begin'#10'  Sleep(Milliseconds);'#10'  Result := 0;'
  +#10'end;'#10#10'  {$ELSE}'#10#10'var'#10'  timerequested, timeremaining: tim'
  +'espec;'#10'begin'#10'  // This is not a very accurate or stable gating sour'
  +'ce... but it''s the'#10'  // only one that''s available for making short te'
  ,'rm measurements.'#10'  timerequested.tv_sec:=Milliseconds div 1000;'#10'  t'
  +'imerequested.tv_nsec:=(Milliseconds mod 1000) * 1000000;'#10'  Result := fp'
  +'nanosleep(@timerequested, @timeremaining) // returns 0 if ok'#10'end;'#10#10
  +'  {$ENDIF}'#10#10'{$ENDIF}'#10#10'function TEpikTimer.GetHardwareTicks: Tic'
  +'kType;'#10'begin'#10'  Result:=FHWTicks.Ticks();'#10'end;'#10#10'function T'
  +'EpikTimer.GetSystemTicks: Ticktype;'#10'begin'#10'  Result:=FSystemTicks.Ti'
  +'cks();'#10'end;'#10#10'procedure TEpikTimer.SetTimebaseSource(const AValue:'
  +' TickSources);'#10#10'  procedure UseSystemTimer;'#10'  begin'#10'    FTime'
  +'BaseSource := SystemTimebase;'#10'    SelectedTimebase := @FSystemTicks;'#10
  +'  end;'#10#10'begin'#10'  case AValue of'#10'    HardwareTimebase:'#10'    '
  +'  try'#10'        if HWTickSupportAvailable then'#10'          begin'#10'  '
  +'          SelectedTimebase:=@FHWTicks;'#10'            FTimeBaseSource:=Har'
  +'dwareTimebase;'#10'            If CorrelationMode<>Manual then CorrelateTim'
  +'ebases'#10'          end'#10'      except // If HW init fails, fall back to'
  +' system tick source'#10'        UseSystemTimer'#10'      end;'#10'    Syste'
  +'mTimeBase: UseSystemTimer'#10'  end'#10'end;'#10#10'function TEpikTimer.Get'
  +'SelectedTimebase: TimebaseData;'#10'begin'#10'  Result := FSelectedTimebase'
  +'^;'#10'end;'#10#10'procedure TEpikTimer.SetSelectedTimebase(const AValue: T'
  +'imebaseData);'#10'begin'#10'  FSelectedTimebase^ := AValue;'#10'end;'#10#10
  +'(* * * * * * * * * * Time measurement core routines * * * * * * * * * *)'#10
  +#10'procedure TEpikTimer.Clear(var T: TimerData);'#10'begin'#10'  with T do'
  +#10'    begin'#10'      Running:=False; StartTime:=0; TotalTicks:=0; TimeBas'
  +'eUsed:=FSelectedTimebase'#10'    end;'#10'end;'#10#10'procedure TEpikTimer.'
  +'Start(var T: TimerData);'#10'begin'#10'  if not T.running then'#10'    With'
  +' FSelectedTimebase^ do'#10'    begin'#10'      T.StartTime:=Ticks()-TicksOv'
  +'erhead;'#10'      T.TimebaseUsed:=FSelectedTimebase;'#10'      T.Running:=T'
  +'rue'#10'    end'#10'end;'#10#10'procedure TEpikTimer.Stop(var T: TimerData)'
  +';'#10'  Var CurTicks:TickType;'#10'Begin'#10'  if T.Running then'#10'    Wi'
  +'th T.TimebaseUsed^ do'#10'    Begin'#10'      CurTicks:=Ticks()-TicksOverhe'
  +'ad; // Back out the call overhead'#10'      T.TotalTicks:=(CurTicks - T.Sta'
  +'rttime)+T.TotalTicks; T.Running:=false'#10'    end'#10'end;'#10#10'function'
  +' TEpikTimer.Elapsed(var T: TimerData): Extended;'#10'var'#10'  CurTicks: Ti'
  +'ckType;'#10'begin'#10'  With T.TimebaseUsed^ do'#10'    if T.Running then'
  +#10'      Begin'#10#10'        CurTicks:=Ticks()-TicksOverhead; // Back out '
  +'the call overhead'#10'        If CorrelationMode>OnTimebaseSelect then Corr'
  +'elateTimebases;'#10#10'        Result := ((CurTicks - T.Starttime)+T.TotalT'
  +'icks) / TicksFrequency'#10'      End'#10'    Else Result := T.TotalTicks / '
  +'TicksFrequency;'#10'end;'#10#10'(* * * * * * * * * * Output formatting rout'
  +'ines  * * * * * * * * * *)'#10#10'function TEpikTimer.ElapsedDHMS(var T: Ti'
  +'merData): String;'#10'var'#10'  Tmp, MS: extended;'#10'  D, H, M, S: Intege'
  +'r;'#10'  P, SM: string;'#10'begin'#10'  Tmp := Elapsed(T);'#10'  P := intto'
  +'str(FSPrecision);'#10'  MS := frac(Tmp); SM:=format(''%0.''+P+''f'',[MS]); '
  +'delete(SM,1,1);'#10'  D := trunc(Tmp / 84600); Tmp:=Trunc(tmp) mod 84600;'
  +#10'  H := trunc(Tmp / 3600); Tmp:=Trunc(Tmp) mod 3600;'#10'  M := Trunc(Tmp'
  +' / 60); S:=(trunc(Tmp) mod 60);'#10'  If FWantDays then'#10'    Result := f'
  +'ormat(''%2.3d:%2.2d:%2.2d:%2.2d'',[D,H,M,S])'#10'  else'#10'    Result := f'
  +'ormat(''%2.2d:%2.2d:%2.2d'',[H,M,S]);'#10'  If FWantMS then Result:=Result+'
  +'SM;'#10'end;'#10#10'function TEpikTimer.ElapsedStr(var T: TimerData): strin'
  +'g;'#10'begin'#10'  Result := format(''%.''+inttostr(FSPrecision)+''f'',[Ela'
  +'psed(T)]);'#10'end;'#10#10'function TEpikTimer.WallClockTime: string;'#10'v'
  +'ar'#10'  Y, D, M, hour, min, sec, ms, us: Word;'#10'{$IFNDEF Windows}'#10' '
  +' t: timeval;'#10'{$ENDIF}'#10'begin'#10'{$IFDEF Windows}'#10'  DecodeDateti'
  +'me(Now, Y, D, M, Hour, min, Sec, ms);'#10'  us:=0;'#10'{$ELSE}'#10'  // "No'
  +'w" doesn''t report milliseconds on Linux... appears to be broken.'#10'  // '
  +'I opted for this approach which also provides microsecond precision.'#10'  '
  +'fpgettimeofday(@t,nil);'#10'  EpochToLocal(t.tv_sec, Y, M, D, hour, min, se'
  +'c);'#10'  ms:=t.tv_usec div 1000; us:=t.tv_usec mod 1000;'#10'{$ENDIF}'#10
  +'  Result:='''';'#10'  If FWantDays then'#10'    Result := Format(''%4.4d/%2'
  +'.2d/%2.2d-'',[Y,M,D]);'#10'  Result := Result + Format(''%2.2d:%2.2d:%2.2d'
  +''',[hour,min,sec]);'#10'  If FWantMS then'#10'    Result := Result + Format'
  +'(''.%3.3d%3.3d'',[ms,us])'#10'end;'#10#10'(* * * Overloaded methods to use '
  +'the component''s internal timer data * * *)'#10#10'procedure TEpikTimer.Cle'
  +'ar; begin Clear(BuiltInTimer) end;'#10'procedure TEpikTimer.Start; begin St'
  +'art(BuiltInTimer) end;'#10'procedure TEpikTimer.Stop;  Begin Stop(BuiltInTi'
  ,'mer) End;'#10'function  TEpikTimer.Elapsed: Extended; begin Result:=Elapsed'
  +'(BuiltInTimer) end;'#10'function  TEpikTimer.ElapsedStr: String; Begin Resu'
  +'lt:=ElapsedStr(BuiltInTimer) end;'#10'function  TEpikTimer.ElapsedDHMS: Str'
  +'ing; begin Result:=ElapsedDHMS(BuiltInTimer) end;'#10#10'(* * * * * * * * *'
  +' * Timebase calibration section  * * * * * * * * * *)'#10#10'// Set up comp'
  +'ensation for call overhead to the Ticks and SystemSleep functions.'#10'// T'
  +'he Timebase record contains Calibration parameters to be used for each'#10
  +'// timebase source. These have to be unique as the output of this measureme'
  +'nt'#10'// is measured in "ticks"... which are different periods for each ti'
  +'mebase.'#10#10'function TEpikTimer.CalibrateCallOverheads(Var Timebase:Time'
  +'baseData):Integer;'#10'var i:Integer; St,Fin,Total:TickType;'#10'begin'#10
  +'  with Timebase, Timebase.CalibrationParms do'#10'  begin'#10'    Total:=0;'
  +' Result:=1;'#10'    for I:=1 to TicksIterations do // First get the base ti'
  +'ck getting overhead'#10'      begin'#10'        St:=Ticks(); Fin:=Ticks();'
  +#10'        Total:=Total+(Fin-St); // dump the first sample'#10'      end;'
  +#10'    TicksOverhead:=Total div TicksIterations;'#10'    Total:=0;'#10'    '
  +'For I:=1 to SleepIterations do'#10'    Begin'#10'      St:=Ticks();'#10'   '
  +'   if SystemSleep(0)<>0 then exit;'#10'      Fin:=Ticks();'#10'      Total:'
  +'=Total+((Fin-St)-TicksOverhead);'#10'    End;'#10'    SleepOverhead:=Total '
  +'div SleepIterations;'#10'    OverheadCalibrated:=True; Result:=0'#10'  End'
  +#10'end;'#10#10'// CalibrateTickFrequency is a fallback in case a microsecon'
  +'d resolution system'#10'// clock isn''t found. It''s still important becaus'
  +'e the long term accuracy of the'#10'// timers will depend on the determinat'
  +'ion of the tick frequency... in other words,'#10'// the number of ticks it '
  +'takes to make a second. If this measurement isn''t'#10'// accurate, the cou'
  +'nters will proportionately drift over time.'#10'//'#10'// The technique use'
  +'d here is to gate a sample of the tick stream with a known'#10'// time refe'
  +'rence which, in this case, is nanosleep. There is a *lot* of jitter'#10'// '
  +'in a nanosleep call so an attempt is made to compensate for some of it here'
  +'.'#10#10'function TEpikTimer.CalibrateTickFrequency(Var Timebase:TimebaseDa'
  +'ta):Integer;'#10'var'#10'  i: Integer;'#10'  Total, SS, SE: TickType;'#10' '
  +' ElapsedTicks, SampleTime: Extended;'#10'begin'#10'  With Timebase, Timebas'
  +'e.CalibrationParms do'#10'  Begin'#10'    Result:=1; //maintain unitialized'
  +' default in case something goes wrong.'#10'    Total:=0;'#10'    For i:=1 t'
  +'o FreqIterations do'#10'      begin'#10'        SS:=Ticks();'#10'        Sy'
  +'stemSleep(FrequencyGateTimeMS);'#10'        SE:=Ticks();'#10'        Total:'
  +'=Total+((SE-SS)-(SleepOverhead+TicksOverhead))'#10'      End;'#10'    //doi'
  +'ng the floating point conversion allows SampleTime parms of < 1 second'#10
  +'    ElapsedTicks:=Total div FreqIterations;'#10'    SampleTime:=FrequencyGa'
  +'teTimeMS;'#10#10'    TicksFrequency:=Trunc( ElapsedTicks / (SampleTime / 10'
  +'00));'#10#10'    FreqCalibrated:=True;'#10'  end;'#10'end;'#10#10'// Grab a'
  +' snapshot of the system and hardware tick sources... as quickly as'#10'// p'
  +'ossible and with overhead compensation. These samples will be used to'#10'/'
  +'/ correct the accuracy of the hardware tick frequency source when precision'
  +#10'// long term measurements are desired.'#10'procedure TEpikTimer.GetCorre'
  +'lationSample(var CorrelationData: TimeBaseCorrelationData);'#10'Var'#10'  T'
  +'icksHW, TicksSys: TickType;'#10'  THW, TSYS: TickCallFunc;'#10'begin'#10'  '
  +'THW:=FHWTicks.Ticks; TSYS:=FSystemTicks.Ticks;'#10'  TicksHW:=THW(); TicksS'
  +'ys:=TSYS();'#10'  With CorrelationData do'#10'    Begin'#10'      SystemTic'
  +'ks:= TicksSys-FSystemTicks.TicksOverhead;'#10'      HWTicks:=TicksHW-FHWTic'
  +'ks.TicksOverhead;'#10'    End'#10'end;'#10#10'(* * * * * * * * * * Timebase'
  +' correlation section  * * * * * * * * * *)'#10#10'{ Get another snapshot of'
  +' the system and hardware tick sources and compute a'#10'  corrected value f'
  +'or the hardware frequency. In a short amount of time, the'#10'  microsecond'
  +' system clock accumulates enough ticks to perform a *very*'#10'  accurate f'
  +'requency measurement of the typically picosecond time stamp counter. }'#10
  +#10'Function TEpikTimer.GetTimebaseCorrelation:TickType;'#10'Var'#10'  HWDif'
  +'f, SysDiff, Corrected: Extended;'#10'begin'#10'  If HWtickSupportAvailable '
  +'then'#10'    Begin'#10'      GetCorrelationSample(UpdatedCorrelationSample)'
  +';'#10'      HWDiff:=UpdatedCorrelationSample.HWTicks-StartupCorrelationSamp'
  +'le.HWTicks;'#10'      SysDiff:=UpdatedCorrelationSample.SystemTicks-Startup'
  +'CorrelationSample.SystemTicks;'#10'      Corrected:=HWDiff / (SysDiff / Def'
  +'aultSystemTicksPerSecond);'#10'      Result:=trunc(Corrected)'#10'    End'
  +#10'  else result:=0'#10'end;'#10#10'{ If an accurate reference is available'
  ,', update the TicksFrequency of the'#10'  hardware timebase. }'#10'procedure'
  +' TEpikTimer.CorrelateTimebases;'#10'begin'#10'  If MicrosecondSystemClockAv'
  +'ailable and HWTickSupportAvailable then'#10'    FHWTicks.TicksFrequency:=Ge'
  +'tTimebaseCorrelation'#10'end;'#10#10'(* * * * * * * * Initialization: Const'
  +'ructor and Destructor  * * * * * * *)'#10#10'constructor TEpikTimer.Create('
  +'AOwner: TComponent);'#10#10'  Procedure InitTimebases;'#10'  Begin'#10#10' '
  +'   { Tick frequency rates are different for the system and HW timebases so '
  +'we'#10'      need to store calibration data in the period format of each on'
  +'e. }'#10'    FSystemTicks.Ticks:=@SystemTicks; // Point to Ticks routine'#10
  +'    With FSystemTicks.CalibrationParms do'#10'      Begin'#10'        FreqC'
  +'alibrated:=False;'#10'        OverheadCalibrated:=False;'#10'        TicksI'
  +'terations:=5;'#10'        SleepIterations:=10;'#10'        FrequencyGateTim'
  +'eMS:=100;'#10'        FreqIterations:=1;'#10'      End;'#10#10'    // Initi'
  +'alize the HW tick source data'#10'    FHWCapabilityDataAvailable:=False;'#10
  +'    FHWTickSupportAvailable:=False;'#10'    FHWTicks.Ticks:=@NullHardwareTi'
  +'cks; // returns a zero if no HW support'#10'    FHWTicks.TicksFrequency:=1;'
  +#10'    With FHWTicks.CalibrationParms do'#10'      Begin'#10'        FreqCa'
  +'librated:=False;'#10'        OverheadCalibrated:=False;'#10'        TicksIt'
  +'erations:=10;'#10'        SleepIterations:=20;'#10'        FrequencyGateTim'
  +'eMS:=150;'#10'        FreqIterations:=1;'#10'      End;'#10#10'    if HasHa'
  +'rdwareCapabilityData then'#10'      Begin'#10'        FHWCapabilityDataAvai'
  +'lable:=True;'#10'        If HasHardwareTickCounter then'#10'          Begin'
  +#10'            FHWTicks.Ticks:=@HardwareTicks;'#10'            FHWTickSuppo'
  +'rtAvailable:=CalibrateCallOverheads(FHWTicks)=0'#10'          End'#10'     '
  +' end;'#10'         '#10'    CalibrateCallOverheads(FSystemTicks);'#10'    C'
  +'alibrateTickFrequency(FSystemTicks);'#10#10'    // Overheads are set... get'
  +' starting timestamps for long term calibration runs'#10'    GetCorrelationS'
  +'ample(StartupCorrelationSample);'#10'    With FSystemTicks do'#10'      If '
  +'(TicksFrequency>(DefaultSystemTicksPerSecond-SystemTicksNormalRangeLimit)) '
  +'and'#10'        (TicksFrequency<(DefaultSystemTicksPerSecond+SystemTicksNor'
  +'malRangeLimit)) then'#10'        Begin // We''ve got a good microsecond sys'
  +'tem clock'#10'          FSystemTicks.TicksFrequency:=DefaultSystemTicksPerS'
  +'econd; // assume it''s pure'#10'          FMicrosecondSystemClockAvailable:'
  +'=True;'#10'          If FHWTickSupportAvailable then'#10'            Begin'
  +#10'              SystemSleep(FHWTicks.CalibrationParms.FrequencyGateTimeMS)'
  +'; // rough gate'#10'              CorrelateTimebases'#10'            End'#10
  +'        end'#10'      else'#10'        Begin'#10'          FMicrosecondSyst'
  +'emClockAvailable:=False;'#10'          If FHWTickSupportAvailable then'#10
  +'            CalibrateTickFrequency(FHWTicks) // sloppy but usable fallback '
  +'calibration'#10'        End;'#10' End;'#10#10'begin'#10'  inherited Create('
  +'AOwner);'#10'  StringPrecision:=6; FWantMS:=True; FWantDays:=True;'#10'  In'
  +'itTimebases;'#10'  CorrelationMode:=OnTimebaseSelect;'#10'  // Default is t'
  +'he safe, cross-platform but less precise system timebase'#10'  TimebaseSour'
  +'ce:=SystemTimebase;'#10'  Clear(BuiltInTimer)'#10'end;'#10#10'destructor TE'
  +'pikTimer.Destroy;'#10'begin'#10'  inherited Destroy;'#10'  // here in case '
  +'we need to clean something up in a later version'#10'end;'#10#10'end.'#10#10
]);
