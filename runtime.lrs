LazarusResources.Add('rt','PAS',[
  '{'#13#10'    Copyright (c) 2017 Pascal Riekenberg'#13#10#13#10'    LazProfil'
  +'er: Runtime unit'#13#10#13#10'    See the file COPYING.modifiedLGPL.txt, in'
  +'cluded in this distribution,'#13#10'    for details about the license.'#13
  +#10#13#10'    This program is distributed in the hope that it will be useful'
  +','#13#10'    but WITHOUT ANY WARRANTY; without even the implied warranty of'
  +#13#10'    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.'#13#10#13#10
  +' **********************************************************************}'#13
  +#10#13#10'unit LazProfilerRunTime;'#13#10#13#10'{$mode objfpc}{$H+}'#13#10#13
  +#10'interface'#13#10#13#10'uses'#13#10'  Classes, SysUtils, LazProfilerCore;'
  +#13#10#13#10'var'#13#10'  LazProfiler: TLazProfiler;'#13#10#13#10'implementa'
  +'tion'#13#10#13#10'initialization'#13#10#13#10'  LazProfiler := TLazProfiler'
  +'.Create(ParamStr(0));'#13#10#13#10'finalization'#13#10#13#10'  FreeAndNil(L'
  +'azProfiler);'#13#10#13#10'end.'#13#10#13#10
]);
LazarusResources.Add('core','PAS',[
  '{'#13#10'    Copyright (c) 2017 Pascal Riekenberg'#13#10#13#10'    LazProfil'
  +'er: Core unit'#13#10#13#10'    See the file COPYING.modifiedLGPL.txt, inclu'
  +'ded in this distribution,'#13#10'    for details about the license.'#13#10
  +#13#10'    This program is distributed in the hope that it will be useful,'
  +#13#10'    but WITHOUT ANY WARRANTY; without even the implied warranty of'#13
  +#10'    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.'#13#10#13#10' *'
  +'*********************************************************************}'#13
  +#10#13#10'unit LazProfilerCore;'#13#10#13#10'{$mode objfpc}{$H+}'#13#10#13#10
  +'interface'#13#10#13#10'uses'#13#10'  Classes, SysUtils,'#13#10'  Generics.C'
  +'ollections, Generics.Defaults,'#13#10'  EpikTimer;'#13#10#13#10'type'#13#10
  +#13#10'  { TLPProc }'#13#10#13#10'  TLPProcList = class;'#13#10#13#10'  TLPP'
  +'roc = class'#13#10'  private'#13#10'    fName,'#13#10'    fNameOfClass,'#13
  +#10'    fUnitName,'#13#10'    fFileName: String;'#13#10'    fRow: Integer;'
  +#13#10'    fNet,'#13#10'    fGross: QWord;'#13#10'    fCount: Integer;'#13#10
  +'    fCalls,'#13#10'    fCalledBy: TLPProcList;'#13#10'    fInstrument: Bool'
  +'ean;'#13#10'  public'#13#10'    constructor Create(pName, pNameOfProc, pUni'
  +'tName, pFileName: String;'#13#10'      pRow: Integer);'#13#10'    destructo'
  +'r Destroy; override;'#13#10'    procedure Init;'#13#10'    procedure Calls('
  +'pProc: TLPProc);'#13#10'    procedure CalledBy(pProc: TLPProc);'#13#10'    '
  +'property Name: String read fName write fName;'#13#10'    property NameOfCla'
  +'ss: String read fNameOfClass write fNameOfClass;'#13#10'    property UnitNa'
  +'me: String read fUnitName write fUnitName;'#13#10'    property FileName: St'
  +'ring read fFileName write fFileName;'#13#10'    property Row: Integer read '
  +'fRow write fRow;'#13#10'    property Count: Integer read fCount write fCoun'
  +'t;'#13#10'    property Net: QWord read fNet write fNet;'#13#10'    property'
  +' Gross: QWord read fGross write fGross;'#13#10'    property Instrument: Boo'
  +'lean read fInstrument write fInstrument;'#13#10'  end;'#13#10'  PLPProc = ^'
  +'TLPProc;'#13#10#13#10'  { TLPProcList }'#13#10#13#10'  TLPCustomProcList = '
  +'specialize TObjectList<TLPProc>;'#13#10#13#10'  TLPProcList = class(TLPCust'
  +'omProcList)'#13#10'  public'#13#10'    procedure Init;'#13#10'    procedure'
  +' Convert(pTicks: ticktype);'#13#10'    procedure SaveToStringList(pList: TS'
  +'tringList);'#13#10'    procedure LoadFromStringList(pList: TStringList);'#13
  +#10'  end;'#13#10#13#10'  { TLPStackFrame }'#13#10#13#10'  TLPStackFrame = c'
  +'lass;'#13#10'  TLPStackFrameList = specialize TObjectList<TLPStackFrame>;'
  +#13#10#13#10'  TLPStackFrame = class'#13#10'  private'#13#10'    fProc: TLPP'
  +'roc;'#13#10'    fChildList: TLPStackFrameList;'#13#10'    fParent: TLPStack'
  +'Frame;'#13#10'    fRunning: Boolean;'#13#10'    fTicksInit,'#13#10'    fTic'
  +'ksStart,'#13#10'    fTicksEnd,'#13#10'    fTicksExit,'#13#10'    fNet,'#13
  +#10'    fGross,'#13#10'    fOverhead,'#13#10'    fOff: TickType;'#13#10'  pr'
  +'otected'#13#10'  public'#13#10'    procedure Calc;'#13#10'    procedure Cle'
  +'anupChilds;'#13#10'    constructor Create(pProc: TLPProc; pParent: TLPStack'
  +'Frame);'#13#10'    destructor Destroy; override;'#13#10'  end;'#13#10#13#10
  +'  { TLPProcUsing }'#13#10#13#10'  TLPProcUsing = class'#13#10'  private'#13
  +#10'    fProc: TLPProc;'#13#10'    fCount: Integer;'#13#10'  protected'#13#10
  +'  public'#13#10'    procedure Inc;'#13#10'    constructor Create(pProc: TLP'
  +'Proc);'#13#10'  end;'#13#10#13#10'  { TLPUsingComparer }'#13#10#13#10'  TLP'
  +'UsingComparer = class(TInterfacedObject, specialize IComparer<TLPProcUsing>'
  +')'#13#10'    function Compare(constref Left, Right: TLPProcUsing): Integer;'
  +' overload;'#13#10'  end;'#13#10#13#10'  TLPUsingList = specialize TObjectLi'
  +'st<TLPProcUsing>;'#13#10#13#10#13#10'  { TCustomLazProfiler }'#13#10#13#10
  +'  TCustomLazProfiler = class'#13#10'  protected'#13#10'    fAutoStart: Bool'
  +'ean;'#13#10'    fNeedsRebuild: Boolean;'#13#10'    procedure SaveToFile(pFi'
  +'leName: String; pProcList: TLPProcList);'#13#10'    function LoadFromFile(p'
  +'FileName: String; pProcList: TLPProcList): Boolean;'#13#10'  end;'#13#10#13
  +#10'  { TLazProfiler }'#13#10#13#10'  TLazProfiler = class(TCustomLazProfile'
  +'r)'#13#10'  private'#13#10'    fMasterProc: TLPProc;'#13#10'    fProcList: '
  +'TLPProcList;'#13#10'    fName: String;'#13#10'    fTimer: TEpikTimer;'#13#10
  +'    fTicks: TickType;'#13#10'    fThreads: TList;'#13#10'    fCurStackFrame'
  +': array of TLPStackFrame;'#13#10'    fRunning: Boolean;'#13#10'    fPauseCo'
  +'unt: Integer;'#13#10'    fPauseStartTicks,'#13#10'    fOffTicks: TickType;'
  +#13#10'    fLoaded: Boolean;'#13#10'    Ticks: function: Ticktype of object;'
  +#13#10'    fLock: TRTLCriticalSection;'#13#10'    function GetOffTicks: Tick'
  +'Type;'#13#10'    function HWTicks: Ticktype;'#13#10'    function SysTicks: '
  +'Ticktype;'#13#10'    function ThreadIndex(pThread: TThreadID): Integer;'#13
  ,#10'    procedure Lock;'#13#10'    procedure UnLock;'#13#10'  protected'#13
  +#10'  public'#13#10'    procedure EnterProfiling(pProcID: Integer);'#13#10' '
  +'   procedure ExitProfiling(pProcID: Integer);'#13#10'    procedure StartPro'
  +'filing;'#13#10'    procedure PauseProfiling;'#13#10'    procedure ContinueP'
  +'rofiling;'#13#10'    procedure StopProfiling;'#13#10'    constructor Create'
  +'(pProgramm: String);'#13#10'    destructor Destroy; override;'#13#10'    pr'
  +'operty OffTicks: TickType read GetOffTicks;'#13#10'    property PauseStart:'
  +' TickType read fPauseStartTicks;'#13#10'  end;'#13#10#13#10'const'#13#10'  '
  +'cBackupExtension  = ''.lazprofiler_backup'';'#13#10'  cSettingExtension = '
  +'''.lazprofiler_setting'';'#13#10'  cSettingVersion = 1;'#13#10'  cCoreFileN'
  +'ame = ''LazProfilerCore.pas'';'#13#10'  cRunTimeFileName = ''LazProfilerRun'
  +'Time.pas'';'#13#10'  cTimerFileName = ''EpikTimer.pas'';'#13#10#13#10'imple'
  +'mentation'#13#10#13#10'uses'#13#10'  LazLogger, LazFileUtils, strutils, Dia'
  +'logs;'#13#10#13#10'{ TCustomLazProfiler }'#13#10#13#10'procedure TCustomLaz'
  +'Profiler.SaveToFile(pFileName: String;'#13#10'  pProcList: TLPProcList);'#13
  +#10'var'#13#10'  lFile,'#13#10'  lLine: TStringList;'#13#10'  i: Integer;'#13
  +#10'begin'#13#10'  lFile := TStringList.Create;'#13#10'  lLine := TStringLis'
  +'t.Create;'#13#10'  try'#13#10'    lLine.Delimiter := '';'';'#13#10'    lLin'
  +'e.StrictDelimiter := True;'#13#10'    lLine.Clear;'#13#10'    lLine.Add(Int'
  +'ToStr(cSettingVersion));'#13#10'    lLine.Add(ifthen(fAutoStart, ''AutoStar'
  +'t'', ''''));'#13#10'    lLine.Add(ifthen(fNeedsRebuild, ''NeedsRebuild'', '
  +'''''));'#13#10'    lFile.Add(lLine.DelimitedText);'#13#10'    pProcList.Sav'
  +'eToStringList(lFile);'#13#10'    lFile.SaveToFile(pFileName);'#13#10'  fina'
  +'lly'#13#10'    lLine.Free;'#13#10'    lFile.Free;'#13#10'  end;'#13#10'end;'
  +#13#10#13#10'function TCustomLazProfiler.LoadFromFile(pFileName: String;'#13
  +#10'  pProcList: TLPProcList): Boolean;'#13#10'var'#13#10'  lFile, lLine: TS'
  +'tringList;'#13#10'  lVersion: LongInt;'#13#10'begin'#13#10'  //DebugLn(''  '
  +' LoadFormFile: ''+pFileName);'#13#10'  if not FileExists(pFileName) then'#13
  +#10'    Exit(False);'#13#10'  Result := True;'#13#10'  lFile := TStringList.'
  +'Create;'#13#10'  lLine := TStringList.Create;'#13#10'  pProcList.Clear;'#13
  +#10'  try'#13#10'    lFile.LoadFromFile(pFileName);'#13#10'    if lFile.Coun'
  +'t >= 1 then begin'#13#10'      lLine.Delimiter := '';'';'#13#10'      lLine'
  +'.StrictDelimiter := True;'#13#10'      lLine.DelimitedText := lFile[0];'#13
  +#10'      if lLine.Count >= 3 then begin'#13#10'        lVersion := StrToInt'
  +'(lLine[0]);'#13#10'        If UpperCase(lLine[1]) = ''AUTOSTART'' then'#13
  +#10'          fAutoStart := True;'#13#10'        If UpperCase(lLine[2]) = '''
  +'NEEDSREBUILD'' then'#13#10'          fNeedsRebuild := True;'#13#10'      en'
  +'d else'#13#10'        Exit;'#13#10'      lFile.Delete(0);'#13#10'      if l'
  +'File.Count > 0 then'#13#10'        pProcList.LoadFromStringList(lFile);'#13
  +#10'    end;'#13#10'    //DebugLn(''   Count=''+IntToStr(pProcList.Count));'
  +#13#10'  finally'#13#10'    lLine.Free;'#13#10'    lFile.Free;'#13#10'  end;'
  +#13#10'end;'#13#10#13#10'{ TLPUsingComparer }'#13#10#13#10'function TLPUsing'
  +'Comparer.Compare(constref Left, Right: TLPProcUsing): Integer;'#13#10'begin'
  +#13#10'  if @Left.fProc < @Right.fProc then'#13#10'    Result := -1'#13#10' '
  +' else if @Left.fProc > @Right.fProc then'#13#10'    Result := 1'#13#10'  el'
  +'se'#13#10'    Result := 0;'#13#10'end;'#13#10#13#10'{ TLPProcUsing }'#13#10
  +#13#10'procedure TLPProcUsing.Inc;'#13#10'begin'#13#10'  fCount := fCount + '
  +'1;'#13#10'end;'#13#10#13#10'constructor TLPProcUsing.Create(pProc: TLPProc)'
  +';'#13#10'begin'#13#10'  fProc := pProc;'#13#10'  fCount := 1;'#13#10'end;'
  +#13#10#13#10'{ TLPStackFrame }'#13#10#13#10'procedure TLPStackFrame.Calc;'#13
  +#10'var'#13#10'  i: Integer;'#13#10'begin'#13#10'  if fNet <> -1 then'#13#10
  +'    exit;'#13#10'  { calc times }'#13#10'  fNet := fTicksEnd - fTicksStart;'
  +#13#10'  fGross := fTicksExit - fTicksInit;'#13#10'  fOverhead := fGross - f'
  +'Net;'#13#10'  { handle Childs }'#13#10'  for i := 0 to fChildList.Count - 1'
  +' do begin'#13#10'    fChildList[i].Calc;'#13#10'    fNet := fNet - fChildLi'
  +'st[i].fGross;'#13#10'    fOverhead := fOverhead + fChildList[i].fOverhead;'
  +#13#10'  end;'#13#10'  FreeAndNil(fChildList);'#13#10'  { store infos }'#13
  +#10'  if Assigned(fProc) and fRunning then begin'#13#10'    fProc.Count := f'
  +'Proc.Count + 1;'#13#10'    fProc.fNet := fProc.fNet + fNet - fOff;'#13#10' '
  +'   fProc.fGross := fProc.fGross + fGross - fOverhead - fOff;'#13#10'  end;'
  +#13#10'end;'#13#10#13#10'procedure TLPStackFrame.CleanupChilds;'#13#10'var'
  +#13#10'  i: Integer;'#13#10'begin'#13#10'  for i := 0 to fChildList.Count - '
  +'1 do'#13#10'    fChildList[i].Calc;'#13#10'end;'#13#10#13#10'constructor TL'
  +'PStackFrame.Create(pProc: TLPProc; pParent: TLPStackFrame);'#13#10'begin'#13
  ,#10'  fProc := pProc;'#13#10'  fParent := pParent;'#13#10'  if Assigned(fPar'
  +'ent) then'#13#10'    fParent.fChildList.Add(Self);'#13#10'  fNet := -1;'#13
  +#10'  fGross := -1;'#13#10'  fChildList := TLPStackFrameList.Create;'#13#10
  +'end;'#13#10#13#10'destructor TLPStackFrame.Destroy;'#13#10'begin'#13#10'  f'
  +'ChildList.Free;'#13#10'  inherited Destroy;'#13#10'end;'#13#10#13#10'{ TLPP'
  +'rocList }'#13#10#13#10'procedure TLPProcList.Init;'#13#10'var'#13#10'  i: I'
  +'nteger;'#13#10'begin'#13#10'  for i := 0 to Count -1 do'#13#10'    Items[i]'
  +'.Init;'#13#10'end;'#13#10#13#10'procedure TLPProcList.Convert(pTicks: TickT'
  +'ype);'#13#10'var'#13#10'  i: Integer;'#13#10'begin'#13#10'  for i := 0 to C'
  +'ount - 1 do begin'#13#10'    Items[i].Net := trunc(Items[i].Net / pTicks * '
  +'1000000000);'#13#10'    Items[i].Gross := trunc(Items[i].Gross / pTicks * 1'
  +'000000000);'#13#10'  end;'#13#10'end;'#13#10#13#10'procedure TLPProcList.Sa'
  +'veToStringList(pList: TStringList);'#13#10'var'#13#10'  lLine: TStringList;'
  +#13#10'  i: Integer;'#13#10'begin'#13#10'  lLine := TStringList.Create;'#13
  +#10'  try'#13#10'    lLine.Delimiter := '';'';'#13#10'    lLine.StrictDelimi'
  +'ter := True;'#13#10'    for i := 0 to Count - 1 do begin'#13#10'      lLine'
  +'.Clear;'#13#10'      lLine.Add(Items[i].Name);'#13#10'      lLine.Add(Items'
  +'[i].NameOfClass);'#13#10'      lLine.Add(Items[i].UnitName);'#13#10'      l'
  +'Line.Add(Items[i].FileName);'#13#10'      lLine.Add(IntToStr(Items[i].Row))'
  +';'#13#10'      lLine.Add(IntToStr(Items[i].Count));'#13#10'      lLine.Add('
  +'IntToStr(Items[i].Net));'#13#10'      lLine.Add(IntToStr(Items[i].Gross));'
  +#13#10'      lLine.Add(BoolToStr(Items[i].Instrument, True));'#13#10'      p'
  +'List.Add(lLine.DelimitedText);'#13#10'    end;'#13#10'  finally'#13#10'    '
  +'lLine.Free;'#13#10'  end;'#13#10'end;'#13#10#13#10'procedure TLPProcList.Lo'
  +'adFromStringList(pList: TStringList);'#13#10'var'#13#10'  lLine: TStringLis'
  +'t;'#13#10'  i: Integer;'#13#10'begin'#13#10'  lLine := TStringList.Create;'
  +#13#10'  try'#13#10'    lLine.Delimiter := '';'';'#13#10'    lLine.StrictDel'
  +'imiter := True;'#13#10'    if pList.Count = 0 then'#13#10'      exit;'#13#10
  +'    for i := 0 to pList.Count - 1 do begin'#13#10'      lLine.DelimitedText'
  +' := pList[i];'#13#10'      if lLine.Count >= 9 then begin'#13#10'        Ad'
  +'d(TLPProc.Create(lLine[0], lLine[1], lLine[2], lLine[3], StrToInt(lLine[4])'
  +'));'#13#10'        Last.Count := StrToInt(lLine[5]);'#13#10'        Last.Ne'
  +'t := StrToQWord(lLine[6]);'#13#10'        Last.Gross := StrToQWord(lLine[7]'
  +');'#13#10'        Last.Instrument := StrToBool(lLine[8]);'#13#10'        //'
  +'if not Last.Instrument then'#13#10'        //  DebugLn(''*** do not instrum'
  +'ent ''+Last.Name);'#13#10'      end;'#13#10'    end;'#13#10'  finally'#13#10
  +'    lLine.Free;'#13#10'  end;'#13#10'end;'#13#10#13#10'{ TLazProfiler }'#13
  +#10#13#10'function TLazProfiler.GetOffTicks: TickType;'#13#10'begin'#13#10' '
  +' if fPauseCount = 0 then begin'#13#10'    Result := fOffTicks;'#13#10'    f'
  +'OffTicks := 0;'#13#10'  end else'#13#10'    Result := 0;'#13#10'end;'#13#10
  +#13#10'function TLazProfiler.HWTicks: Ticktype;'#13#10'begin'#13#10'  Result'
  +' := fTimer.HWTimebase.Ticks() - fTimer.HWTimebase.TicksOverhead;'#13#10'end'
  +';'#13#10#13#10'function TLazProfiler.SysTicks: Ticktype;'#13#10'begin'#13#10
  +'  Result := fTimer.SysTimebase.Ticks() - fTimer.SysTimebase.TicksOverhead;'
  +#13#10'end;'#13#10#13#10'function TLazProfiler.ThreadIndex(pThread: TThreadI'
  +'D): Integer;'#13#10'var'#13#10'  lCurStackFrame: TLPStackFrame;'#13#10'begi'
  +'n'#13#10'  Result := fThreads.IndexOf(Pointer(pThread));'#13#10'  if Result'
  +' = -1 then begin'#13#10'    Result := fThreads.Add(Pointer(pThread));'#13#10
  +'    if fThreads.Count > Length(fCurStackFrame) then'#13#10'      SetLength('
  +'fCurStackFrame, fThreads.Count + 100);'#13#10'    lCurStackFrame := TLPStac'
  +'kFrame.Create(fMasterProc, nil);'#13#10'    lCurStackFrame.fTicksInit := Ti'
  +'cks();'#13#10'    lCurStackFrame.fTicksStart := lCurStackFrame.fTicksInit;'
  +#13#10'    fCurStackFrame[Result] := lCurStackFrame;'#13#10'  end;'#13#10'en'
  +'d;'#13#10#13#10'procedure TLazProfiler.Lock;'#13#10'begin'#13#10'  EnterCri'
  +'ticalsection(fLock);'#13#10'end;'#13#10#13#10'procedure TLazProfiler.UnLock'
  +';'#13#10'begin'#13#10'  LeaveCriticalsection(fLock);'#13#10'end;'#13#10#13
  +#10'procedure TLazProfiler.EnterProfiling(pProcID: Integer);'#13#10'var'#13
  +#10'  lTimeStamp: TickType;'#13#10'  lCurStackFrame: TLPStackFrame;'#13#10' '
  +' lIdx: Integer;'#13#10'begin'#13#10'  lTimeStamp := Ticks();'#13#10'  Lock;'
  +#13#10'  try'#13#10'    if pProcID >= fProcList.Count then begin'#13#10'    '
  +'  ShowMessage(''TLazProfiler.EnterProfiling: pProcID >= fProcList.Count: '''
  +'+IntToStr(pProcID)+''>=''+IntToStr(fProcList.Count));'#13#10'      Exit;'#13
  +#10'    end;'#13#10'    lIdx := ThreadIndex(ThreadID);'#13#10'    lCurStackF'
  +'rame := fCurStackFrame[lIdx];'#13#10'    lCurStackFrame := TLPStackFrame.Cr'
  ,'eate(fProcList[pProcID], lCurStackFrame);'#13#10'    fCurStackFrame[lIdx] :'
  +'= lCurStackFrame;'#13#10'    lCurStackFrame.fRunning := fRunning;'#13#10'  '
  +'  lCurStackFrame.fTicksInit := lTimeStamp;'#13#10'  finally'#13#10'    UnLo'
  +'ck;'#13#10'  end;'#13#10'  lCurStackFrame.fTicksStart := Ticks();'#13#10'en'
  +'d;'#13#10#13#10'procedure TLazProfiler.ExitProfiling(pProcID: Integer);'#13
  +#10'var'#13#10'  lTimeStamp: TickType;'#13#10'  lCurStackFrame: TLPStackFram'
  +'e;'#13#10'  lIdx: Integer;'#13#10'begin'#13#10'  lTimeStamp := Ticks();'#13
  +#10'  Lock;'#13#10'  try'#13#10'    lIdx := ThreadIndex(ThreadID);'#13#10'  '
  +'  lCurStackFrame := fCurStackFrame[lIdx];'#13#10'    lCurStackFrame.fTicksE'
  +'nd := lTimeStamp;'#13#10'    if pProcID >= fProcList.Count then begin'#13#10
  +'      ShowMessage(''TLazProfiler.ExitProfiling: pProcID >= fProcList.Count:'
  +' ''+IntToStr(pProcID)+''>=''+IntToStr(fProcList.Count));'#13#10'      Exit;'
  +#13#10'    end;'#13#10'    if lCurStackFrame.fProc <> fProcList[pProcID] the'
  +'n'#13#10'      ShowMessage(''TLazProfiler.ExitProfiling: Stack mismatch: '''
  +'+lCurStackFrame.fProc.Name+''<->''+fProcList[pProcID].name);'#13#10'    lCu'
  +'rStackFrame.fOff := OffTicks;'#13#10'    lCurStackFrame.CleanupChilds;'#13
  +#10'    fCurStackFrame[lIdx] := lCurStackFrame.fParent;'#13#10'  finally'#13
  +#10'    UnLock;'#13#10'  end;'#13#10'  lCurStackFrame.fTicksExit := Ticks();'
  +#13#10'end;'#13#10#13#10'procedure TLazProfiler.StartProfiling;'#13#10'begin'
  +#13#10'  fRunning := True;'#13#10'  DebugLn(''### LazProfiler: Start'');'#13
  +#10'end;'#13#10#13#10'procedure TLazProfiler.PauseProfiling;'#13#10'begin'#13
  +#10'  if fPauseCount = 0 then'#13#10'    fPauseStartTicks := Ticks();'#13#10
  +'  inc(fPauseCount);'#13#10'end;'#13#10#13#10'procedure TLazProfiler.Continu'
  +'eProfiling;'#13#10'begin'#13#10'  dec(fPauseCount);'#13#10'  if fRunning th'
  +'en begin'#13#10'    if fPauseCount = 0 then begin'#13#10'      if fPauseSta'
  +'rtTicks <> 0 then'#13#10'        fOffTicks := fOffTicks + (Ticks() - fPause'
  +'StartTicks)'#13#10'      else'#13#10'        fOffTicks := 0;'#13#10'      f'
  +'PauseStartTicks := 0;'#13#10'    end;'#13#10'  end else begin'#13#10'    fO'
  +'ffTicks := 0;'#13#10'    fPauseStartTicks := 0;'#13#10'  end;'#13#10'end;'
  +#13#10#13#10'procedure TLazProfiler.StopProfiling;'#13#10'begin'#13#10'  fRu'
  +'nning := False;'#13#10'  DebugLn(''### LazProfiler: Stop'');'#13#10'end;'#13
  +#10#13#10'constructor TLazProfiler.Create(pProgramm: String);'#13#10'var'#13
  +#10'  lCurStackFrame: TLPStackFrame;'#13#10'begin'#13#10'  inherited Create;'
  +#13#10'  InitCriticalSection(fLock);'#13#10'  fName := AppendPathDelim(Extra'
  +'ctFileDir(pProgramm))+ExtractFileNameOnly(pProgramm);'#13#10'  fProcList :='
  +' TLPProcList.Create(True);'#13#10'  fTimer := TEpikTimer.Create(nil);'#13#10
  +'  if fTimer.HWCapabilityDataAvailable and fTimer.HWTickSupportAvailable the'
  +'n begin'#13#10'    Ticks := @HWTicks;'#13#10'    fTicks := fTimer.HWTimebas'
  +'e.TicksFrequency;'#13#10'    DebugLn(''### LazProfiler: HWTicks used. Freq='
  +'''+IntToStr(fTicks));'#13#10'  end else begin'#13#10'    Ticks := @SysTicks'
  +';'#13#10'    fTicks := fTimer.SysTimebase.TicksFrequency;'#13#10'    DebugL'
  +'n(''### LazProfiler: SysTicks used. Freq=''+IntToStr(fTicks));'#13#10'  end'
  +';'#13#10'  fMasterProc := TLPProc.Create(''Master'', '''', '''', '''', -1);'
  +#13#10'  fOffTicks := 0;'#13#10'  fThreads := TList.Create;'#13#10'  lCurSta'
  +'ckFrame := TLPStackFrame.Create(fMasterProc, nil);'#13#10'  lCurStackFrame.'
  +'fTicksInit := Ticks();'#13#10'  lCurStackFrame.fTicksStart := lCurStackFram'
  +'e.fTicksInit;'#13#10'  SetLength(fCurStackFrame, 100);'#13#10'  fCurStackFr'
  +'ame[fThreads.Add(Pointer(ThreadID))] := lCurStackFrame;'#13#10'  fLoaded :='
  +' LoadFromFile(fName+cSettingExtension, fProcList);'#13#10'  fRunning := fAu'
  +'toStart;'#13#10'end;'#13#10#13#10'destructor TLazProfiler.Destroy;'#13#10'v'
  +'ar'#13#10'  i: Integer;'#13#10'  lCurStackFrame: TLPStackFrame;'#13#10'begi'
  +'n'#13#10'  fMasterProc.Free;'#13#10'  for i := 0 to fThreads.Count - 1 do b'
  +'egin'#13#10'    lCurStackFrame := fCurStackFrame[i];'#13#10'    lCurStackFr'
  +'ame.fTicksEnd := Ticks();'#13#10'    lCurStackFrame.fTicksExit := lCurStack'
  +'Frame.fTicksEnd;'#13#10'    lCurStackFrame.Calc;'#13#10'    lCurStackFrame.'
  +'Free;'#13#10'  end;'#13#10'  { calc percentages }'#13#10#13#10'  { free res'
  +'ources }'#13#10'  fThreads.Free;'#13#10'  SetLength(fCurStackFrame, 0);'#13
  +#10'  fTimer.Free;'#13#10'  if fTicks > 0 then'#13#10'    fProcList.Convert('
  +'fTicks)'#13#10'  else'#13#10'    DebugLn(''***** LazProfiler: fTicks=''+Int'
  +'ToStr(fTicks));'#13#10'  if fLoaded then'#13#10'    SaveToFile(fName+cSetti'
  +'ngExtension, fProcList);'#13#10'  fProcList.Free;'#13#10'  DoneCriticalSect'
  +'ion(fLock);'#13#10'  inherited Destroy;'#13#10'end;'#13#10#13#10'{ TLPProc '
  +'}'#13#10#13#10'procedure TLPProc.Init;'#13#10'begin'#13#10'  fCount := 0;'
  +#13#10'  fNet := 0;'#13#10'  fGross := 0;'#13#10'end;'#13#10#13#10'construct'
  ,'or TLPProc.Create(pName, pNameOfProc, pUnitName, pFileName: String; pRow: I'
  +'nteger'#13#10'  );'#13#10'begin'#13#10'  fName := pName;'#13#10'  fNameOfCl'
  +'ass := pNameOfProc;'#13#10'  fUnitName := pUnitName;'#13#10'  fFileName := '
  +'pFileName;'#13#10'  fRow := pRow;'#13#10'  fInstrument := True;'#13#10'  In'
  +'it;'#13#10'end;'#13#10#13#10'destructor TLPProc.Destroy;'#13#10'begin'#13#10
  +'  fCalls.Free;'#13#10'  fCalledBy.Free;'#13#10'  inherited Destroy;'#13#10
  +'end;'#13#10#13#10'procedure TLPProc.Calls(pProc: TLPProc);'#13#10'begin'#13
  +#10'  if not Assigned(fCalls) then'#13#10'    fCalls := TLPProcList.Create(F'
  +'alse);'#13#10'end;'#13#10#13#10'procedure TLPProc.CalledBy(pProc: TLPProc);'
  +#13#10'begin'#13#10'  if not Assigned(fCalledBy) then'#13#10'    fCalledBy :'
  +'= TLPProcList.Create(False);'#13#10'end;'#13#10#13#10'end.'#13#10#13#10
]);
LazarusResources.Add('timer','PAS',[
  'unit EpikTimer;'#10#10'{ Name: EpikTimer'#10'  Description: Precision timer/'
  +'stopwatch component for Lazarus/FPC'#10'  Author: Tom Lisjac <netdxr@gmail.'
  +'com>'#10'  Started on: June 24, 2003'#10'  Features:'#10'    Dual selectabl'
  +'e timebases: Default:System (uSec timeofday or "now" in Win32)'#10'        '
  +'                       Optional: Pentium Time Stamp Counter.'#10'    Defaul'
  +'t timebase should work on most Unix systems of any architecture.'#10'    Ti'
  +'mebase correlation locks time stamp counter accuracy to system clock.'#10' '
  +'   Timers can be started, stopped, paused and resumed.'#10'    Unlimited nu'
  +'mber of timers can be implemented with one component.'#10'    Low resources'
  +' required: 25 bytes per timer; No CPU overhead.'#10'    Internal call overh'
  +'ead compensation.'#10'    System sleep function'#10'    Designed to support'
  +' multiple operating systems and Architectures'#10'    Designed to support o'
  +'ther hardware tick sources'#10'            '#10'  Credits: Thanks to Martin'
  +' Waldenburg for a lot of great ideas for using'#10'           the Pentium'''
  +'s RDTSC instruction in wmFastTime and QwmFastTime.'#10'}'#10#10'{ Copyright'
  +' (C) 2003-2006 by Tom Lisjac <netdxr@gmail.com>,'#10'   Felipe Monteiro de '
  +'Carvalho and Marcel Minderhoud'#10#10'  This library is licensed on the sam'
  +'e Modifyed LGPL as Free Pascal RTL and LCL are'#10#10'  Please contact the '
  +'author if you''d like to use this component but the Modifyed LGPL'#10'  doe'
  +'sn''t work with your project licensing.'#10#10'  This program is distribute'
  +'d in the hope that it will be useful, but WITHOUT'#10'  ANY WARRANTY; witho'
  +'ut even the implied warranty of MERCHANTABILITY or'#10'  FITNESS FOR A PART'
  +'ICULAR PURPOSE.'#10'  '#10'  Contributor(s):'#10'  '#10'  * Felipe Monteiro'
  +' de Carvalho (felipemonteiro.carvalho@gmail.com)'#10'  '#10'  * Marcel Mind'
  +'erhoud'#10'  '#10'}'#10'{'#10' Known Issues'#10#10'   - Tested on Linux but'
  +' no other Lazarus/FPC supported Unix platforms'#10'   - If system doesn''t '
  +'have microsecond system clock resolution, the component'#10'     falls back'
  +' to a single gated measurement of the hardware tick frequency via'#10'     '
  +'nanosleep. This usually results in poor absolute accuracy due large amounts'
  +#10'     of jitter in nanosleep... but for typical short term measurements, '
  +'this'#10'     shouldn''t be a problem.'#10#10'}'#10#10'{$IFDEF FPC}'#10'  {'
  +'$MODE DELPHI}{$H+}'#10'{$ENDIF}'#10#10'{$IFNDEF FPC}'#10'  {$DEFINE Windows'
  +'}'#10'{$ENDIF}'#10#10'{$IFDEF Win32}'#10'  {$DEFINE Windows}'#10'{$ENDIF}'
  +#10#10'interface'#10#10'uses'#10'{$IFDEF Windows}'#10'  Windows, MMSystem,'
  +#10'{$ELSE}'#10'  unix, unixutil, BaseUnix,'#10'{$ENDIF}'#10'  Classes, SysU'
  +'tils, dateutils;'#10#10'Const'#10'  DefaultSystemTicksPerSecond = 1000000; '
  +'//Divisor for microsecond resolution'#10'  { HW Tick frequency falls back t'
  +'o gated measurement if the initial system'#10'    clock measurement is outs'
  +'ide this range plus or minus.}'#10'  SystemTicksNormalRangeLimit = 100000;'
  +#10#10'type'#10#10'  TickType = Int64; // Global declaration for all tick pr'
  +'ocessing routines'#10'  '#10'  FormatPrecision = 1..12; // Number of decima'
  +'l places in elapsed text format'#10'  '#10'  // Component powers up in Syst'
  +'em mode to provide some cross-platform safety.'#10'  TickSources = (SystemT'
  +'imebase, HardwareTimebase); // add others if desired'#10#10'  (* * * * * * '
  +'* * * * * Timebase declarations  * * * * * * * * * * *)'#10'  '#10'  { Ther'
  +'e are two timebases currently implemented in this component but others'#10
  +'    can be added by declaring them as "TickSources", adding a TimebaseData'
  +#10'    variable to the Private area of TEpikTimer and providing a "Ticks" r'
  +'outine'#10'    that returns the current counter value.'#10'    '#10'    Tim'
  +'ebases are "calibrated" during initialization by taking samples of the'#10
  +'    execution times of the SystemSleep and Ticks functions measured with in'
  +' the'#10'    tick period of the selected timebase. At runtime, these values'
  +' are retrieved'#10'    and used to remove the call overhead to the best deg'
  +'ree possible.'#10'    '#10'    System latency is always present and contrib'
  +'utes "jitter" to the edges of'#10'    the sample measurements. This is espe'
  +'cially true if a microsecond system'#10'    clock isn''t detected on the ho'
  +'st system and a fallback gated measurement'#10'    (based on nanosleep in L'
  +'inux and sleep in Win32) is used to determine the'#10'    timebase frequenc'
  +'y. This is sufficient for short term measurements where'#10'    high resolu'
  +'tion comparisons are desired... but over a long measurement'#10'    period,'
  +' the hardware and system wall clock will diverge significantly.'#10'    '#10
  +'    If a microsecond system clock is found, timebase correlation is used to'
  +#10'    synchronize the hardware counter and system clock. This is described'
  +' below.'#10'  }'#10#10'  TickCallFunc = function: Ticktype; // Ticks interf'
  ,'ace function'#10'  '#10'  // Contains timebase overhead compensation factor'
  +'s in ticks for each timebase'#10'  TimebaseCalibrationParameters = record'
  +#10'    FreqCalibrated: Boolean; // Indicates that the tickfrequency has bee'
  +'n calibrated'#10'    OverheadCalibrated: Boolean; // Indicates that all cal'
  +'l overheads have been calibrated'#10'    TicksIterations: Integer; // numbe'
  +'r of iterations to use when measuring ticks overhead'#10'    SleepIteration'
  +'s: Integer; // number of iterations to use when measuring SystemSleep overh'
  +'ead'#10'    FreqIterations: Integer;  // number of iterations to use when m'
  +'easuring ticks frequency'#10'    FrequencyGateTimeMS: Integer;  // gate tim'
  +'e to use when measuring ticks frequency'#10'   end;'#10#10'  // This record'
  +' defines the Timebase context'#10'  TimebaseData = record'#10'    Calibrati'
  +'onParms: TimebaseCalibrationParameters; // Calibration data for this timeba'
  +'se'#10'    TicksFrequency: TickType; // Tick frequency of this timebase'#10
  +'    TicksOverhead: Ticktype;  // Ticks call overhead in TicksFrequency for '
  +'this timebase'#10'    SleepOverhead: Ticktype;   // SystemSleep all overhea'
  +'d in TicksFrequency for this timebase'#10'    Ticks: TickCallFunc; // all m'
  +'ethods get their ticks from this function when selected'#10'  end;'#10'  '
  +#10'  TimeBaseSelector = ^TimebaseData;'#10'  '#10'  (*  * * * * * * * * * *'
  +' Timebase Correlation  * * * * * * * * * * *)'#10#10'  { The TimeBaseCorrel'
  +'ation record stores snapshot samples of both the system'#10'    ticks (the '
  +'source of known accuracy) and the hardware tick source (the'#10'    source '
  +'of high measurement resolution). An initial sample is taken at power'#10'  '
  +'  up. The CorrelationMode property sets where and when updates are acquired'
  +'.'#10#10'    When an update snapshot is acquired, the differences between i'
  +'t and the'#10'    startup value can be used to calculate the hardware clock'
  +' frequency with'#10'    high precision from the accuracy of the accumulated'
  +' system clocks. The'#10'    longer time that elapses between startup and a '
  +'call to "CorrelateTimebases",'#10'    the better the accuracy will be. On a'
  +' 1.6 Ghz P4, it only takes a few'#10'    seconds to achieve measurement cer'
  +'tainty down to a few Hertz.'#10#10'    Of course this system is only as goo'
  +'d as your system clock accuracy, so'#10'    it''s a good idea to periodical'
  +'ly sync it with NTP or against another source'#10'    of known accuracy if '
  +'you want to maximize the long term of the timers. }'#10#10'  TimebaseCorrel'
  +'ationData = record'#10'    SystemTicks: TickType;'#10'    HWTicks: TickType'
  +';'#10'  end;'#10#10'  // If the Correlation property is set to automatic, a'
  +'n update sample is taken'#10'  // anytime the user calls Start or Elapsed. '
  +'If in manual, the correlation'#10'  // update is only done when "CorrelateT'
  +'imebases" is called. Doing updates'#10'  // with every call adds a small am'
  +'ount of overhead... and after the first few'#10'  // minutes of operation, '
  +'there won''t be very much correcting to do!'#10#10'  CorrelationModes=(Manu'
  +'al, OnTimebaseSelect, OnGetElapsed);'#10'  '#10'  (* * * * * * * * * * * Ti'
  +'mer Data record structure  * * * * * * * * * * *)'#10'  '#10'  // This is t'
  +'he timer data context. There is an internal declaration of this'#10'  // re'
  +'cord and overloaded methods if you only want to use the component for a'#10
  +'  // single timer... or you can declare multiple TimerData records in your'
  +#10'  // program and create as many instances as you want with only a single'
  +#10'  // component on the form. See the "Stopwatch" methods in the TEpikTime'
  +'r class.'#10'  '#10'  // Each timers points to the timebase that started it'
  +'... so you can mix system'#10'  // and hardware timers in the same applicat'
  +'ion.'#10#10'  TimerData = record'#10'    Running:Boolean; // Timer is curre'
  +'ntly running'#10'    TimebaseUsed:TimeBaseSelector; // keeps timer aligned '
  +'with the source that started it.'#10'    StartTime:TickType; // Ticks sampl'
  +'e when timer was started'#10'    TotalTicks:TickType; // Total ticks... for'
  +' snapshotting and pausing'#10'  end;'#10'  '#10'  TEpikTimer= class(TCompon'
  +'ent)'#10'    private'#10'      BuiltInTimer:TimerData; // Used to provide a'
  +' single built-in timer;'#10'      FHWTickSupportAvailable:Boolean; // True '
  +'if hardware tick support is available'#10'      FHWCapabilityDataAvailable:'
  +'Boolean; // True if hardware tick support is available'#10'      FHWTicks:T'
  +'imeBaseData;     // The hardware timebase'#10'      FSystemTicks:TimeBaseDa'
  +'ta; // The system timebase'#10'      FSelectedTimebase:TimeBaseSelector; //'
  +' Pointer to selected database'#10'      '#10'      FTimeBaseSource: TickSou'
  +'rces; // use hardware or system timebase'#10'      FWantDays: Boolean; // t'
  +'rue if days are to be displayed in string returns'#10'      FWantMS: Boolea'
  +'n; // True to display milliseconds in string formatted calls'#10'      FSPr'
  ,'ecision: FormatPrecision; // number of digits to display in string calls'#10
  +'      FMicrosecondSystemClockAvailable:Boolean; // true if system has micro'
  +'second clock'#10'      '#10'      StartupCorrelationSample:TimebaseCorrelat'
  +'ionData; // Starting ticks correlation snapshot'#10'      UpdatedCorrelatio'
  +'nSample:TimebaseCorrelationData; // Snapshot of last correlation sample'#10
  +'      FCorrelationMode: CorrelationModes; // mode to control when correlati'
  +'on updates are performed'#10'    protected'#10'      function GetSelectedTi'
  +'mebase: TimebaseData;'#10'      procedure SetSelectedTimebase(const AValue:'
  +' TimebaseData);'#10'      procedure SetTimebaseSource(const AValue: TickSou'
  +'rces); //setter for TB'#10'      Procedure GetCorrelationSample(Var Correla'
  +'tionData:TimeBaseCorrelationData);'#10'    public'#10'      {              '
  +'         Stopwatch emulation routines'#10'        These routines behave exa'
  +'ctly like a conventional stopwatch with start,'#10'        stop, elapsed (l'
  +'ap) and clear methods. The timers can be started,'#10'        stopped and r'
  +'esumed. The Elapsed routines provide a "lap" time analog.'#10#10'        Th'
  +'e methods are overloaded to make it easy to simply use the component''s'#10
  +'        BuiltInTimer as a single timer... or to declare your own TimerData '
  +'records'#10'        in order to implement unlimited numbers of timers using'
  +' a single component'#10'        on the form. The timers are very resource e'
  +'fficient because they consume'#10'        no CPU overhead and only require '
  +'about 25 bytes of memory.'#10'      }'#10#10'      // Stops and resets the '
  +'timer'#10'      procedure Clear; overload;// Call this routine to use the b'
  +'uilt-in timer record'#10'      procedure Clear(Var T:TimerData); overload; '
  +'// pass your TimerData record to this one'#10#10'      //Start or resume a '
  +'stopped timer'#10'      procedure Start; overload;'#10'      procedure Star'
  +'t(Var T:TimerData); overload;'#10#10'      //Stop or pause a timer'#10'    '
  +'  procedure Stop; overload;'#10'      procedure Stop(Var T:TimerData); over'
  +'load;'#10#10'      //Return elapsed time in seconds as an extended type'#10
  +'      function Elapsed:Extended; overload;'#10'      function Elapsed(var T'
  +': TimerData):Extended; overload;'#10#10'      //Return a string in Day:Hour'
  +':Minute:Second format. Milliseconds can be'#10'      //optionally appended '
  +'via the WantMilliseconds property'#10'      function ElapsedDHMS:String; ov'
  +'erload;'#10'      function ElapsedDHMS(var T: TimerData):String; overload;'
  +#10#10'      //Return a string in the format of seconds.milliseconds'#10'   '
  +'   function ElapsedStr:String; overload;'#10'      function ElapsedStr(var '
  +'T:TimerData):String; overload;'#10#10'      function WallClockTime:String; '
  +'// Return time of day string from system time'#10#10'      //Overhead compe'
  +'nsated system sleep to provide a best possible precision delay'#10'      fu'
  +'nction SystemSleep(Milliseconds: Integer):integer; Virtual;'#10#10'      //'
  +'Diagnostic taps for development and fine grained timebase adjustment'#10'  '
  +'    property HWTimebase: TimeBaseData read FHWTicks write FHWTicks; // The '
  +'hardware timebase'#10'      property SysTimebase: TimebaseData read FSystem'
  +'Ticks write FSystemTicks;'#10'      function GetHardwareTicks:TickType; // '
  +'return raw tick value from hardware source'#10'      function GetSystemTick'
  +'s:Ticktype;   // Return system tick value(in microseconds of Epoch time)'#10
  +'      function GetTimebaseCorrelation:TickType;'#10'      function Calibrat'
  +'eCallOverheads(Var TimeBase:TimebaseData) : Integer; Virtual;'#10'      fun'
  +'ction CalibrateTickFrequency(Var TimeBase:TimebaseData): Integer; Virtual;'
  +#10#10'      property MicrosecondSystemClockAvailable:Boolean read FMicrosec'
  +'ondSystemClockAvailable;'#10'      property SelectedTimebase:TimebaseSelect'
  +'or read FSelectedTimebase write FSelectedTimebase;'#10'      property HWTic'
  +'kSupportAvailable:Boolean read FHWTickSupportAvailable;'#10'      property '
  +'HWCapabilityDataAvailable:Boolean read FHWCapabilityDataAvailable;'#10'    '
  +'  procedure CorrelateTimebases; // Manually call to do timebase correlation'
  +' snapshot and update'#10#10'      constructor Create(AOwner:TComponent); Ov'
  +'erride;'#10'      destructor Destroy; Override;'#10'    Published'#10'     '
  +' property StringPrecision: FormatPrecision read FSPrecision write FSPrecisi'
  +'on;'#10'      property WantMilliseconds: Boolean read FWantMS write FWantMS'
  +';'#10'      property WantDays: Boolean read FWantDays write FWantDays;'#10
  +'      property TimebaseSource: TickSources read FTimeBaseSource write SetTi'
  +'mebaseSource;'#10'      property CorrelationMode:CorrelationModes read FCor'
  +'relationMode write FCorrelationMode;'#10'  end;'#10#10#10'implementation'#10
  +#10'(* * * * * * * * * * * * * * Timebase Section  * * * * * * * * * * * * *'
  +')'#10'{'#10'  There are two tick sources defined in this section. The first'
  ,' uses a hardware'#10'  source which, in this case, is the Pentium''s intern'
  +'al 64 Time Stamp Counter.'#10'  The second source (the default) uses the gi'
  +'ven environment''s most precision'#10'  "timeofday" system call so it can w'
  +'ork across OS platforms and architectures.'#10'  '#10'  The hardware timer'
  +'''s accuracy depends on the frequency of the timebase tick'#10'  source tha'
  +'t drives it... in other words, how many of the timebase''s ticks'#10'  ther'
  +'e are in a second. This frequency is measured by capturing a sample of the'
  +#10'  timebase ticks for a known period against a source of known accuracy. '
  +'There'#10'  are two ways to do this.'#10'  '#10'  The first is to capture a'
  +' large sample of ticks from both the unknown and'#10'  known timing sources'
  +'. Then the frequency of the unknown tick stream can be'#10'  calculated by:'
  +' UnknownSampleTicks / (KnownSampleTicks / KnownTickFrequency).'#10'  Over a'
  +' short period of time, this can provide a precise synchronization'#10'  mec'
  +'hanism that effectively locks the measurements taken with the high'#10'  re'
  +'solution source to the known accuracy of the system clock.'#10#10'  The fir'
  +'st method depends on the existance of an accurate system time source of'#10
  +'  microsecond resolution. If the host system doesn''t provide this, the sec'
  +'ond'#10'  fallback method is to gate the unknown tick stream by a known tim'
  +'e. This isn''t'#10'  as good because it usually involves calling a system "'
  +'delay" routine that'#10'  usually has a lot of overhead "jitter" and non-de'
  +'terministic behavior. This'#10'  approach is usable, however, for short ter'
  +'m, high resolution comparisons where'#10'  absolute accuracy isn''t importa'
  +'nt.'#10'}'#10#10'(* * * * * * * * Start of i386 Hardware specific code  * *'
  +' * * * * *)'#10#10'{$IFDEF CPUI386}'#10'{ Some references for this section '
  +'can be found at:'#10'      http://www.sandpile.org/ia32/cpuid.htm'#10'     '
  +' http://www.sandpile.org/ia32/opc_2.htm'#10'      http://www.sandpile.org/i'
  +'a32/msr.htm'#10'}'#10#10'// Pentium specific... push and pop the flags and '
  +'check for CPUID availability'#10'function HasHardwareCapabilityData: Boolea'
  +'n;'#10'begin'#10'  asm'#10'   PUSHFD'#10'   POP    EAX'#10'   MOV    EDX,EA'
  +'X'#10'   XOR    EAX,$200000'#10'   PUSH   EAX'#10'   POPFD'#10'   PUSHFD'#10
  +'   POP    EAX'#10'   XOR    EAX,EDX'#10'   JZ     @EXIT'#10'   MOV    AL,TR'
  +'UE'#10'   @EXIT:'#10'  end;'#10'end;'#10#10'function HasHardwareTickCounter'
  +': Boolean;'#10'  var FeatureFlags: Longword;'#10'  begin'#10'    FeatureFla'
  +'gs:=0;'#10'    asm'#10'      PUSH   EBX'#10'      XOR    EAX,EAX'#10'      '
  +'DW     $A20F'#10'      POP    EBX'#10'      CMP    EAX,1'#10'      JL     @'
  +'EXIT'#10'      XOR    EAX,EAX'#10'      MOV    EAX,1'#10'      PUSH   EBX'
  +#10'      DW     $A20F'#10'      MOV    FEATUREFLAGS,EDX'#10'      POP    EB'
  +'X'#10'      @EXIT:'#10'    end;'#10'    Result := (FeatureFlags and $10) <>'
  +' 0;'#10'  end;'#10#10'// Execute the Pentium''s RDTSC instruction to access'
  +' the counter value.'#10'function HardwareTicks: TickType; assembler; asm DW'
  +' 0310FH end;'#10#10'(* * * * * * * * End of i386 Hardware specific code  * '
  +'* * * * * *)'#10#10#10'// These are here for architectures that don''t have'
  +' a precision hardware'#10'// timing source. They''ll return zeros for overh'
  +'ead values. The timers'#10'// will work but there won''t be any error compe'
  +'nsation for long'#10'// term accuracy.'#10'{$ELSE} // add other architectur'
  +'es and hardware specific tick sources here'#10'function HasHardwareCapabili'
  +'tyData: Boolean; begin Result:=False end;'#10'function HasHardwareTickCount'
  +'er: Boolean; begin Result:=false end;'#10'function HardwareTicks:TickType; '
  +'begin result:=0 end;'#10'{$ENDIF}'#10#10'function NullHardwareTicks:TickTyp'
  +'e; begin Result:=0 end;'#10#10'// Return microsecond normalized time source'
  +' for a given platform.'#10'// This should be sync''able to an external time'
  +' standard (via NTP, for example).'#10'function SystemTicks: TickType;'#10'{'
  +'$IFDEF Windows}'#10'begin'#10'  QueryPerformanceCounter(Result);'#10'  //Re'
  +'sult := Int64(TimeStampToMSecs(DateTimeToTimeStamp(Now)) * 1000) // an alte'
  +'rnative Win32 timebase'#10'{$ELSE}'#10'var t : timeval;'#10'begin'#10'  fpg'
  +'ettimeofday(@t,nil);'#10'   // Build a 64 bit microsecond tick from the sec'
  +'onds and microsecond longints'#10'  Result := (TickType(t.tv_sec) * 1000000'
  +') + t.tv_usec;'#10'{$ENDIF}'#10'end;'#10#10'function TEpikTimer.SystemSleep'
  +'(Milliseconds: Integer):Integer;'#10'{$IFDEF Windows}'#10#10'begin'#10'  Sl'
  +'eep(Milliseconds);'#10'  Result := 0;'#10'end;'#10#10'{$ELSE}'#10#10'  {$IF'
  +'DEF CPUX86_64}'#10#10'begin'#10'  Sleep(Milliseconds);'#10'  Result := 0;'
  +#10'end;'#10#10'  {$ELSE}'#10#10'var'#10'  timerequested, timeremaining: tim'
  +'espec;'#10'begin'#10'  // This is not a very accurate or stable gating sour'
  +'ce... but it''s the'#10'  // only one that''s available for making short te'
  ,'rm measurements.'#10'  timerequested.tv_sec:=Milliseconds div 1000;'#10'  t'
  +'imerequested.tv_nsec:=(Milliseconds mod 1000) * 1000000;'#10'  Result := fp'
  +'nanosleep(@timerequested, @timeremaining) // returns 0 if ok'#10'end;'#10#10
  +'  {$ENDIF}'#10#10'{$ENDIF}'#10#10'function TEpikTimer.GetHardwareTicks: Tic'
  +'kType;'#10'begin'#10'  Result:=FHWTicks.Ticks();'#10'end;'#10#10'function T'
  +'EpikTimer.GetSystemTicks: Ticktype;'#10'begin'#10'  Result:=FSystemTicks.Ti'
  +'cks();'#10'end;'#10#10'procedure TEpikTimer.SetTimebaseSource(const AValue:'
  +' TickSources);'#10#10'  procedure UseSystemTimer;'#10'  begin'#10'    FTime'
  +'BaseSource := SystemTimebase;'#10'    SelectedTimebase := @FSystemTicks;'#10
  +'  end;'#10#10'begin'#10'  case AValue of'#10'    HardwareTimebase:'#10'    '
  +'  try'#10'        if HWTickSupportAvailable then'#10'          begin'#10'  '
  +'          SelectedTimebase:=@FHWTicks;'#10'            FTimeBaseSource:=Har'
  +'dwareTimebase;'#10'            If CorrelationMode<>Manual then CorrelateTim'
  +'ebases'#10'          end'#10'      except // If HW init fails, fall back to'
  +' system tick source'#10'        UseSystemTimer'#10'      end;'#10'    Syste'
  +'mTimeBase: UseSystemTimer'#10'  end'#10'end;'#10#10'function TEpikTimer.Get'
  +'SelectedTimebase: TimebaseData;'#10'begin'#10'  Result := FSelectedTimebase'
  +'^;'#10'end;'#10#10'procedure TEpikTimer.SetSelectedTimebase(const AValue: T'
  +'imebaseData);'#10'begin'#10'  FSelectedTimebase^ := AValue;'#10'end;'#10#10
  +'(* * * * * * * * * * Time measurement core routines * * * * * * * * * *)'#10
  +#10'procedure TEpikTimer.Clear(var T: TimerData);'#10'begin'#10'  with T do'
  +#10'    begin'#10'      Running:=False; StartTime:=0; TotalTicks:=0; TimeBas'
  +'eUsed:=FSelectedTimebase'#10'    end;'#10'end;'#10#10'procedure TEpikTimer.'
  +'Start(var T: TimerData);'#10'begin'#10'  if not T.running then'#10'    With'
  +' FSelectedTimebase^ do'#10'    begin'#10'      T.StartTime:=Ticks()-TicksOv'
  +'erhead;'#10'      T.TimebaseUsed:=FSelectedTimebase;'#10'      T.Running:=T'
  +'rue'#10'    end'#10'end;'#10#10'procedure TEpikTimer.Stop(var T: TimerData)'
  +';'#10'  Var CurTicks:TickType;'#10'Begin'#10'  if T.Running then'#10'    Wi'
  +'th T.TimebaseUsed^ do'#10'    Begin'#10'      CurTicks:=Ticks()-TicksOverhe'
  +'ad; // Back out the call overhead'#10'      T.TotalTicks:=(CurTicks - T.Sta'
  +'rttime)+T.TotalTicks; T.Running:=false'#10'    end'#10'end;'#10#10'function'
  +' TEpikTimer.Elapsed(var T: TimerData): Extended;'#10'var'#10'  CurTicks: Ti'
  +'ckType;'#10'begin'#10'  With T.TimebaseUsed^ do'#10'    if T.Running then'
  +#10'      Begin'#10#10'        CurTicks:=Ticks()-TicksOverhead; // Back out '
  +'the call overhead'#10'        If CorrelationMode>OnTimebaseSelect then Corr'
  +'elateTimebases;'#10#10'        Result := ((CurTicks - T.Starttime)+T.TotalT'
  +'icks) / TicksFrequency'#10'      End'#10'    Else Result := T.TotalTicks / '
  +'TicksFrequency;'#10'end;'#10#10'(* * * * * * * * * * Output formatting rout'
  +'ines  * * * * * * * * * *)'#10#10'function TEpikTimer.ElapsedDHMS(var T: Ti'
  +'merData): String;'#10'var'#10'  Tmp, MS: extended;'#10'  D, H, M, S: Intege'
  +'r;'#10'  P, SM: string;'#10'begin'#10'  Tmp := Elapsed(T);'#10'  P := intto'
  +'str(FSPrecision);'#10'  MS := frac(Tmp); SM:=format(''%0.''+P+''f'',[MS]); '
  +'delete(SM,1,1);'#10'  D := trunc(Tmp / 84600); Tmp:=Trunc(tmp) mod 84600;'
  +#10'  H := trunc(Tmp / 3600); Tmp:=Trunc(Tmp) mod 3600;'#10'  M := Trunc(Tmp'
  +' / 60); S:=(trunc(Tmp) mod 60);'#10'  If FWantDays then'#10'    Result := f'
  +'ormat(''%2.3d:%2.2d:%2.2d:%2.2d'',[D,H,M,S])'#10'  else'#10'    Result := f'
  +'ormat(''%2.2d:%2.2d:%2.2d'',[H,M,S]);'#10'  If FWantMS then Result:=Result+'
  +'SM;'#10'end;'#10#10'function TEpikTimer.ElapsedStr(var T: TimerData): strin'
  +'g;'#10'begin'#10'  Result := format(''%.''+inttostr(FSPrecision)+''f'',[Ela'
  +'psed(T)]);'#10'end;'#10#10'function TEpikTimer.WallClockTime: string;'#10'v'
  +'ar'#10'  Y, D, M, hour, min, sec, ms, us: Word;'#10'{$IFNDEF Windows}'#10' '
  +' t: timeval;'#10'{$ENDIF}'#10'begin'#10'{$IFDEF Windows}'#10'  DecodeDateti'
  +'me(Now, Y, D, M, Hour, min, Sec, ms);'#10'  us:=0;'#10'{$ELSE}'#10'  // "No'
  +'w" doesn''t report milliseconds on Linux... appears to be broken.'#10'  // '
  +'I opted for this approach which also provides microsecond precision.'#10'  '
  +'fpgettimeofday(@t,nil);'#10'  EpochToLocal(t.tv_sec, Y, M, D, hour, min, se'
  +'c);'#10'  ms:=t.tv_usec div 1000; us:=t.tv_usec mod 1000;'#10'{$ENDIF}'#10
  +'  Result:='''';'#10'  If FWantDays then'#10'    Result := Format(''%4.4d/%2'
  +'.2d/%2.2d-'',[Y,M,D]);'#10'  Result := Result + Format(''%2.2d:%2.2d:%2.2d'
  +''',[hour,min,sec]);'#10'  If FWantMS then'#10'    Result := Result + Format'
  +'(''.%3.3d%3.3d'',[ms,us])'#10'end;'#10#10'(* * * Overloaded methods to use '
  +'the component''s internal timer data * * *)'#10#10'procedure TEpikTimer.Cle'
  +'ar; begin Clear(BuiltInTimer) end;'#10'procedure TEpikTimer.Start; begin St'
  +'art(BuiltInTimer) end;'#10'procedure TEpikTimer.Stop;  Begin Stop(BuiltInTi'
  ,'mer) End;'#10'function  TEpikTimer.Elapsed: Extended; begin Result:=Elapsed'
  +'(BuiltInTimer) end;'#10'function  TEpikTimer.ElapsedStr: String; Begin Resu'
  +'lt:=ElapsedStr(BuiltInTimer) end;'#10'function  TEpikTimer.ElapsedDHMS: Str'
  +'ing; begin Result:=ElapsedDHMS(BuiltInTimer) end;'#10#10'(* * * * * * * * *'
  +' * Timebase calibration section  * * * * * * * * * *)'#10#10'// Set up comp'
  +'ensation for call overhead to the Ticks and SystemSleep functions.'#10'// T'
  +'he Timebase record contains Calibration parameters to be used for each'#10
  +'// timebase source. These have to be unique as the output of this measureme'
  +'nt'#10'// is measured in "ticks"... which are different periods for each ti'
  +'mebase.'#10#10'function TEpikTimer.CalibrateCallOverheads(Var Timebase:Time'
  +'baseData):Integer;'#10'var i:Integer; St,Fin,Total:TickType;'#10'begin'#10
  +'  with Timebase, Timebase.CalibrationParms do'#10'  begin'#10'    Total:=0;'
  +' Result:=1;'#10'    for I:=1 to TicksIterations do // First get the base ti'
  +'ck getting overhead'#10'      begin'#10'        St:=Ticks(); Fin:=Ticks();'
  +#10'        Total:=Total+(Fin-St); // dump the first sample'#10'      end;'
  +#10'    TicksOverhead:=Total div TicksIterations;'#10'    Total:=0;'#10'    '
  +'For I:=1 to SleepIterations do'#10'    Begin'#10'      St:=Ticks();'#10'   '
  +'   if SystemSleep(0)<>0 then exit;'#10'      Fin:=Ticks();'#10'      Total:'
  +'=Total+((Fin-St)-TicksOverhead);'#10'    End;'#10'    SleepOverhead:=Total '
  +'div SleepIterations;'#10'    OverheadCalibrated:=True; Result:=0'#10'  End'
  +#10'end;'#10#10'// CalibrateTickFrequency is a fallback in case a microsecon'
  +'d resolution system'#10'// clock isn''t found. It''s still important becaus'
  +'e the long term accuracy of the'#10'// timers will depend on the determinat'
  +'ion of the tick frequency... in other words,'#10'// the number of ticks it '
  +'takes to make a second. If this measurement isn''t'#10'// accurate, the cou'
  +'nters will proportionately drift over time.'#10'//'#10'// The technique use'
  +'d here is to gate a sample of the tick stream with a known'#10'// time refe'
  +'rence which, in this case, is nanosleep. There is a *lot* of jitter'#10'// '
  +'in a nanosleep call so an attempt is made to compensate for some of it here'
  +'.'#10#10'function TEpikTimer.CalibrateTickFrequency(Var Timebase:TimebaseDa'
  +'ta):Integer;'#10'var'#10'  i: Integer;'#10'  Total, SS, SE: TickType;'#10' '
  +' ElapsedTicks, SampleTime: Extended;'#10'begin'#10'  With Timebase, Timebas'
  +'e.CalibrationParms do'#10'  Begin'#10'    Result:=1; //maintain unitialized'
  +' default in case something goes wrong.'#10'    Total:=0;'#10'    For i:=1 t'
  +'o FreqIterations do'#10'      begin'#10'        SS:=Ticks();'#10'        Sy'
  +'stemSleep(FrequencyGateTimeMS);'#10'        SE:=Ticks();'#10'        Total:'
  +'=Total+((SE-SS)-(SleepOverhead+TicksOverhead))'#10'      End;'#10'    //doi'
  +'ng the floating point conversion allows SampleTime parms of < 1 second'#10
  +'    ElapsedTicks:=Total div FreqIterations;'#10'    SampleTime:=FrequencyGa'
  +'teTimeMS;'#10#10'    TicksFrequency:=Trunc( ElapsedTicks / (SampleTime / 10'
  +'00));'#10#10'    FreqCalibrated:=True;'#10'  end;'#10'end;'#10#10'// Grab a'
  +' snapshot of the system and hardware tick sources... as quickly as'#10'// p'
  +'ossible and with overhead compensation. These samples will be used to'#10'/'
  +'/ correct the accuracy of the hardware tick frequency source when precision'
  +#10'// long term measurements are desired.'#10'procedure TEpikTimer.GetCorre'
  +'lationSample(var CorrelationData: TimeBaseCorrelationData);'#10'Var'#10'  T'
  +'icksHW, TicksSys: TickType;'#10'  THW, TSYS: TickCallFunc;'#10'begin'#10'  '
  +'THW:=FHWTicks.Ticks; TSYS:=FSystemTicks.Ticks;'#10'  TicksHW:=THW(); TicksS'
  +'ys:=TSYS();'#10'  With CorrelationData do'#10'    Begin'#10'      SystemTic'
  +'ks:= TicksSys-FSystemTicks.TicksOverhead;'#10'      HWTicks:=TicksHW-FHWTic'
  +'ks.TicksOverhead;'#10'    End'#10'end;'#10#10'(* * * * * * * * * * Timebase'
  +' correlation section  * * * * * * * * * *)'#10#10'{ Get another snapshot of'
  +' the system and hardware tick sources and compute a'#10'  corrected value f'
  +'or the hardware frequency. In a short amount of time, the'#10'  microsecond'
  +' system clock accumulates enough ticks to perform a *very*'#10'  accurate f'
  +'requency measurement of the typically picosecond time stamp counter. }'#10
  +#10'Function TEpikTimer.GetTimebaseCorrelation:TickType;'#10'Var'#10'  HWDif'
  +'f, SysDiff, Corrected: Extended;'#10'begin'#10'  If HWtickSupportAvailable '
  +'then'#10'    Begin'#10'      GetCorrelationSample(UpdatedCorrelationSample)'
  +';'#10'      HWDiff:=UpdatedCorrelationSample.HWTicks-StartupCorrelationSamp'
  +'le.HWTicks;'#10'      SysDiff:=UpdatedCorrelationSample.SystemTicks-Startup'
  +'CorrelationSample.SystemTicks;'#10'      Corrected:=HWDiff / (SysDiff / Def'
  +'aultSystemTicksPerSecond);'#10'      Result:=trunc(Corrected)'#10'    End'
  +#10'  else result:=0'#10'end;'#10#10'{ If an accurate reference is available'
  ,', update the TicksFrequency of the'#10'  hardware timebase. }'#10'procedure'
  +' TEpikTimer.CorrelateTimebases;'#10'begin'#10'  If MicrosecondSystemClockAv'
  +'ailable and HWTickSupportAvailable then'#10'    FHWTicks.TicksFrequency:=Ge'
  +'tTimebaseCorrelation'#10'end;'#10#10'(* * * * * * * * Initialization: Const'
  +'ructor and Destructor  * * * * * * *)'#10#10'constructor TEpikTimer.Create('
  +'AOwner: TComponent);'#10#10'  Procedure InitTimebases;'#10'  Begin'#10#10' '
  +'   { Tick frequency rates are different for the system and HW timebases so '
  +'we'#10'      need to store calibration data in the period format of each on'
  +'e. }'#10'    FSystemTicks.Ticks:=@SystemTicks; // Point to Ticks routine'#10
  +'    With FSystemTicks.CalibrationParms do'#10'      Begin'#10'        FreqC'
  +'alibrated:=False;'#10'        OverheadCalibrated:=False;'#10'        TicksI'
  +'terations:=5;'#10'        SleepIterations:=10;'#10'        FrequencyGateTim'
  +'eMS:=100;'#10'        FreqIterations:=1;'#10'      End;'#10#10'    // Initi'
  +'alize the HW tick source data'#10'    FHWCapabilityDataAvailable:=False;'#10
  +'    FHWTickSupportAvailable:=False;'#10'    FHWTicks.Ticks:=@NullHardwareTi'
  +'cks; // returns a zero if no HW support'#10'    FHWTicks.TicksFrequency:=1;'
  +#10'    With FHWTicks.CalibrationParms do'#10'      Begin'#10'        FreqCa'
  +'librated:=False;'#10'        OverheadCalibrated:=False;'#10'        TicksIt'
  +'erations:=10;'#10'        SleepIterations:=20;'#10'        FrequencyGateTim'
  +'eMS:=150;'#10'        FreqIterations:=1;'#10'      End;'#10#10'    if HasHa'
  +'rdwareCapabilityData then'#10'      Begin'#10'        FHWCapabilityDataAvai'
  +'lable:=True;'#10'        If HasHardwareTickCounter then'#10'          Begin'
  +#10'            FHWTicks.Ticks:=@HardwareTicks;'#10'            FHWTickSuppo'
  +'rtAvailable:=CalibrateCallOverheads(FHWTicks)=0'#10'          End'#10'     '
  +' end;'#10'         '#10'    CalibrateCallOverheads(FSystemTicks);'#10'    C'
  +'alibrateTickFrequency(FSystemTicks);'#10#10'    // Overheads are set... get'
  +' starting timestamps for long term calibration runs'#10'    GetCorrelationS'
  +'ample(StartupCorrelationSample);'#10'    With FSystemTicks do'#10'      If '
  +'(TicksFrequency>(DefaultSystemTicksPerSecond-SystemTicksNormalRangeLimit)) '
  +'and'#10'        (TicksFrequency<(DefaultSystemTicksPerSecond+SystemTicksNor'
  +'malRangeLimit)) then'#10'        Begin // We''ve got a good microsecond sys'
  +'tem clock'#10'          FSystemTicks.TicksFrequency:=DefaultSystemTicksPerS'
  +'econd; // assume it''s pure'#10'          FMicrosecondSystemClockAvailable:'
  +'=True;'#10'          If FHWTickSupportAvailable then'#10'            Begin'
  +#10'              SystemSleep(FHWTicks.CalibrationParms.FrequencyGateTimeMS)'
  +'; // rough gate'#10'              CorrelateTimebases'#10'            End'#10
  +'        end'#10'      else'#10'        Begin'#10'          FMicrosecondSyst'
  +'emClockAvailable:=False;'#10'          If FHWTickSupportAvailable then'#10
  +'            CalibrateTickFrequency(FHWTicks) // sloppy but usable fallback '
  +'calibration'#10'        End;'#10' End;'#10#10'begin'#10'  inherited Create('
  +'AOwner);'#10'  StringPrecision:=6; FWantMS:=True; FWantDays:=True;'#10'  In'
  +'itTimebases;'#10'  CorrelationMode:=OnTimebaseSelect;'#10'  // Default is t'
  +'he safe, cross-platform but less precise system timebase'#10'  TimebaseSour'
  +'ce:=SystemTimebase;'#10'  Clear(BuiltInTimer)'#10'end;'#10#10'destructor TE'
  +'pikTimer.Destroy;'#10'begin'#10'  inherited Destroy;'#10'  // here in case '
  +'we need to clean something up in a later version'#10'end;'#10#10'end.'#10#10
]);
